/**
 * Obsidian-Integrated Kanban Task Management System
 * API Server - Phases 1-3 Complete
 * 
 * Port: 3001
 * Base URL: http://localhost:3001/api/v1
 * WebSocket: ws://localhost:3001
 */

const express = require('express');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const crypto = require('crypto');
const { v4: uuidv4 } = require('uuid');
const matter = require('gray-matter');
const cron = require('node-cron');
const chokidar = require('chokidar');
const http = require('http');
const WebSocket = require('ws');
const { spawn, exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Production agent execution module
const { spawnAgentWithResult, parseAgentOutput } = require('./agent-spawner');

const app = express();
const PORT = 3001;

// ============================================
// CONFIGURATION & CONSTANTS
// ============================================

const PLANS_CONFIG = {
  BASE_DIR: path.join(process.env.HOME, '.openclaw/workspace/plans'),
  ACTIVE_DIR: path.join(process.env.HOME, '.openclaw/workspace/plans/active'),
  ARCHIVE_DIR: path.join(process.env.HOME, '.openclaw/workspace/plans/archive'),
  TEMPLATES_DIR: path.join(process.env.HOME, '.openclaw/workspace/plans/templates'),
  TEMPLATE_FILE: path.join(process.env.HOME, '.openclaw/workspace/plans/templates/plan-template.md'),
  PLANNING_PROMPT: path.join(process.env.HOME, '.openclaw/workspace/plans/templates/planning-agent-prompt.md'),
  EXECUTION_PROMPT: path.join(process.env.HOME, '.openclaw/workspace/plans/templates/execution-agent-prompt.md')
};

const CONFIG = {
  BASE_DIR: path.join(process.env.HOME, 'Desktop/Claw Creations'),
  OUTPUTS_DIR: path.join(process.env.HOME, 'Desktop/Claw Creations/outputs'),
  THUMBNAILS_DIR: path.join(process.env.HOME, 'Desktop/Claw Creations/thumbnails'),
  OBSIDIAN_VAULT: path.join(process.env.HOME, 'Documents/Obsidian/Tasks'),
  OBSIDIAN_VAULT_FULL: path.join(process.env.HOME, 'Documents/Obsidian'),
  TASKS_FILE: path.join(process.env.HOME, 'Desktop/Claw Creations/tasks.json'),
  FILES_FILE: path.join(process.env.HOME, 'Desktop/Claw Creations/files.json'),
  EVENTS_FILE: path.join(process.env.HOME, 'Desktop/Claw Creations/events.json'),
  REPORTS_FILE: path.join(process.env.HOME, 'Desktop/Claw Creations/reports.json'),
  ARCHIVE_FILE: path.join(process.env.HOME, 'Desktop/Claw Creations/archive.json'),
  SYNC_INTERVAL_MS: 30000,
  WATCHER_IGNORE_PATTERNS: [
    '**/.obsidian/**',
    '**/node_modules/**',
    '**/.git/**',
    '**/*.tmp',
    '**/*.swp'
  ]
};

const PRIORITY_WEIGHTS = {
  'P0': 100,
  'P1': 75,
  'P2': 50,
  'P3': 25
};

const STATUS_ORDER = ['backlog', 'today', 'tomorrow', 'done'];

// ============================================
// PLAN STORAGE INFRASTRUCTURE (Phase 1)
// ============================================

/**
 * Initialize plan storage directories
 */
async function initializePlanStorage() {
  const dirs = [
    PLANS_CONFIG.BASE_DIR,
    PLANS_CONFIG.ACTIVE_DIR,
    PLANS_CONFIG.ARCHIVE_DIR,
    PLANS_CONFIG.TEMPLATES_DIR
  ];
  
  for (const dir of dirs) {
    try {
      await fs.mkdir(dir, { recursive: true });
      console.log(`üìÅ Plan directory ready: ${path.relative(process.env.HOME, dir)}`);
    } catch (err) {
      console.warn(`Could not create plan directory ${dir}:`, err.message);
    }
  }
}

/**
 * Write a plan to the active directory
 * @param {string} taskId - Unique task identifier
 * @param {string} planContent - Markdown content of the plan
 * @returns {Promise<string>} Path to the written plan file
 */
async function writePlan(taskId, planContent) {
  try {
    const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    await fs.mkdir(planDir, { recursive: true });
    
    const planPath = path.join(planDir, 'plan.md');
    const timestamp = new Date().toISOString();
    
    // Add metadata header if not present
    let content = planContent;
    if (!content.includes('---')) {
      content = `---
taskId: ${taskId}
created: ${timestamp}
status: draft
---

${content}`;
    }
    
    await fs.writeFile(planPath, content, 'utf8');
    
    // Initialize empty context and log files
    await saveContext(taskId, { created: timestamp, taskId });
    await appendLog(taskId, { 
      timestamp, 
      level: 'info', 
      message: 'Plan created',
      agent: 'planning-agent'
    });
    
    console.log(`üìù Plan written: ${path.relative(PLANS_CONFIG.BASE_DIR, planPath)}`);
    return planPath;
  } catch (err) {
    console.error(`Error writing plan for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * Read a plan from the active directory
 * @param {string} taskId - Unique task identifier
 * @returns {Promise<Object>} Plan data with content and metadata
 */
async function readPlan(taskId) {
  try {
    const planPath = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId, 'plan.md');
    const content = await fs.readFile(planPath, 'utf8');
    const parsed = matter(content);
    
    return {
      taskId,
      content: parsed.content,
      metadata: parsed.data,
      path: planPath
    };
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    }
    console.error(`Error reading plan for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * Check if a plan exists
 * @param {string} taskId - Unique task identifier
 * @returns {Promise<boolean>} True if plan exists
 */
async function planExists(taskId) {
  try {
    const planPath = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId, 'plan.md');
    await fs.access(planPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Archive a completed plan
 * @param {string} taskId - Unique task identifier
 * @param {Object} completionData - Completion metadata
 * @returns {Promise<string>} Path to the archived plan directory
 */
async function archivePlan(taskId, completionData = {}) {
  try {
    const today = new Date().toISOString().split('T')[0];
    const archiveDateDir = path.join(PLANS_CONFIG.ARCHIVE_DIR, today);
    const archiveDir = path.join(archiveDateDir, taskId);
    const activeDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    
    // Ensure archive date directory exists
    await fs.mkdir(archiveDateDir, { recursive: true });
    await fs.mkdir(archiveDir, { recursive: true });
    
    // Read all files from active directory
    let files = [];
    try {
      files = await fs.readdir(activeDir);
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new Error(`No active plan found for task ${taskId}`);
      }
      throw err;
    }
    
    // Move each file to archive
    for (const file of files) {
      const srcPath = path.join(activeDir, file);
      const destPath = path.join(archiveDir, file);
      await fs.copyFile(srcPath, destPath);
      await fs.unlink(srcPath);
    }
    
    // Create completion metadata
    const completionMeta = {
      taskId,
      archivedAt: new Date().toISOString(),
      archivedDate: today,
      ...completionData
    };
    await fs.writeFile(
      path.join(archiveDir, 'completion.json'),
      JSON.stringify(completionMeta, null, 2),
      'utf8'
    );
    
    // Remove empty active directory
    await fs.rmdir(activeDir);
    
    console.log(`üì¶ Plan archived: ${path.relative(PLANS_CONFIG.BASE_DIR, archiveDir)}`);
    return archiveDir;
  } catch (err) {
    console.error(`Error archiving plan for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * List all active plans
 * @returns {Promise<Array>} Array of active plan summaries
 */
async function listActivePlans() {
  try {
    const entries = await fs.readdir(PLANS_CONFIG.ACTIVE_DIR, { withFileTypes: true });
    const plans = [];
    
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const taskId = entry.name;
        try {
          const plan = await readPlan(taskId);
          const context = await loadContext(taskId);
          if (plan) {
            plans.push({
              taskId,
              metadata: plan.metadata,
              created: plan.metadata.created,
              status: plan.metadata.status || 'unknown',
              hasContext: !!context
            });
          }
        } catch (err) {
          console.warn(`Error reading plan ${taskId}:`, err.message);
        }
      }
    }
    
    return plans.sort((a, b) => new Date(b.created) - new Date(a.created));
  } catch (err) {
    if (err.code === 'ENOENT') {
      return [];
    }
    console.error('Error listing active plans:', err);
    throw err;
  }
}

// ============================================
// CONTEXT SNAPSHOT SYSTEM
// ============================================

/**
 * Save context data for a task
 * @param {string} taskId - Unique task identifier
 * @param {Object} contextData - Context data to save
 * @returns {Promise<string>} Path to the context file
 */
async function saveContext(taskId, contextData) {
  try {
    const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    await fs.mkdir(planDir, { recursive: true });
    
    const contextPath = path.join(planDir, 'context.json');
    const timestamp = new Date().toISOString();
    
    const context = {
      taskId,
      updated: timestamp,
      ...contextData
    };
    
    await fs.writeFile(contextPath, JSON.stringify(context, null, 2), 'utf8');
    return contextPath;
  } catch (err) {
    console.error(`Error saving context for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * Load context data for a task
 * @param {string} taskId - Unique task identifier
 * @returns {Promise<Object|null>} Context data or null if not found
 */
async function loadContext(taskId) {
  try {
    const contextPath = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId, 'context.json');
    const data = await fs.readFile(contextPath, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    }
    console.error(`Error loading context for task ${taskId}:`, err);
    throw err;
  }
}

// ============================================
// EXECUTION LOG SYSTEM
// ============================================

/**
 * Append an entry to the execution log
 * @param {string} taskId - Unique task identifier
 * @param {Object} entry - Log entry
 * @returns {Promise<string>} Path to the log file
 */
async function appendLog(taskId, entry) {
  try {
    const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    await fs.mkdir(planDir, { recursive: true });
    
    const logPath = path.join(planDir, 'log.md');
    const timestamp = entry.timestamp || new Date().toISOString();
    
    const level = entry.level || 'info';
    const levelEmoji = {
      'info': '‚ÑπÔ∏è',
      'success': '‚úÖ',
      'warning': '‚ö†Ô∏è',
      'error': '‚ùå',
      'blocker': 'üö´',
      'agent': 'ü§ñ'
    }[level] || '‚ÑπÔ∏è';
    
    const logEntry = `\n## ${timestamp} ${levelEmoji} ${level.toUpperCase()}\n\n`;
    
    if (entry.agent) {
      logEntry + `**Agent:** ${entry.agent}\n\n`;
    }
    
    if (entry.stepNumber) {
      logEntry + `**Step:** ${entry.stepNumber}\n\n`;
    }
    
    logEntry + `${entry.message}\n\n`;
    
    if (entry.details) {
      logEntry + `**Details:** ${entry.details}\n\n`;
    }
    
    if (entry.output) {
      logEntry + `**Output:** ${entry.output}\n\n`;
    }
    
    // Append to file (create if doesn't exist)
    try {
      await fs.appendFile(logPath, logEntry, 'utf8');
    } catch (err) {
      if (err.code === 'ENOENT') {
        // Create new log file with header
        const header = `# Execution Log: ${taskId}\n\n*Auto-generated execution log*\n`;
        await fs.writeFile(logPath, header + logEntry, 'utf8');
      } else {
        throw err;
      }
    }
    
    return logPath;
  } catch (err) {
    console.error(`Error appending log for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * Read the execution log for a task
 * @param {string} taskId - Unique task identifier
 * @returns {Promise<string|null>} Log content or null if not found
 */
async function readLog(taskId) {
  try {
    const logPath = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId, 'log.md');
    return await fs.readFile(logPath, 'utf8');
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    }
    console.error(`Error reading log for task ${taskId}:`, err);
    throw err;
  }
}

/**
 * Log an agent spawn event
 * @param {string} taskId - Task being executed
 * @param {string} agentType - Type of agent spawned
 * @param {string} stepNumber - Step being executed
 */
async function logAgentSpawn(taskId, agentType, stepNumber = null) {
  return appendLog(taskId, {
    timestamp: new Date().toISOString(),
    level: 'agent',
    agent: agentType,
    stepNumber,
    message: `Agent spawned: ${agentType}`,
    details: stepNumber ? `Executing step ${stepNumber}` : 'Initializing'
  });
}

/**
 * Log a step completion event
 * @param {string} taskId - Task being executed
 * @param {number} stepNumber - Completed step number
 * @param {string} result - Result description
 */
async function logStepComplete(taskId, stepNumber, result) {
  return appendLog(taskId, {
    timestamp: new Date().toISOString(),
    level: 'success',
    stepNumber,
    message: `Step ${stepNumber} completed`,
    output: result
  });
}

/**
 * Log an error or blocker event
 * @param {string} taskId - Task being executed
 * @param {string} error - Error description
 * @param {boolean} isBlocker - Whether this blocks execution
 */
async function logError(taskId, error, isBlocker = false) {
  return appendLog(taskId, {
    timestamp: new Date().toISOString(),
    level: isBlocker ? 'blocker' : 'error',
    message: isBlocker ? 'Execution blocked' : 'Error encountered',
    details: error
  });
}

// ============================================
// WEBSOCKET SERVER FOR REAL-TIME UPDATES
// ============================================

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// Store connected clients
const wsClients = new Set();

wss.on('connection', (ws) => {
  console.log('üì° WebSocket client connected');
  wsClients.add(ws);
  
  ws.on('close', () => {
    console.log('üì° WebSocket client disconnected');
    wsClients.delete(ws);
  });
  
  ws.on('error', (err) => {
    console.error('WebSocket error:', err);
    wsClients.delete(ws);
  });
});

// Broadcast to all connected clients
function broadcastUpdate(type, data) {
  const message = JSON.stringify({ type, data, timestamp: new Date().toISOString() });
  wsClients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}

// ============================================
// FILE WATCHER FOR OBSIDIAN SYNC
// ============================================

let obsidianWatcher = null;
let lastObsidianUpdate = null;

async function initFileWatcher() {
  try {
    // Ensure Tasks directory exists
    await fs.mkdir(CONFIG.OBSIDIAN_VAULT, { recursive: true });
    await fs.mkdir(path.join(CONFIG.OBSIDIAN_VAULT, 'today'), { recursive: true });
    await fs.mkdir(path.join(CONFIG.OBSIDIAN_VAULT, 'tomorrow'), { recursive: true });
    await fs.mkdir(path.join(CONFIG.OBSIDIAN_VAULT, 'backlog'), { recursive: true });
    await fs.mkdir(path.join(CONFIG.OBSIDIAN_VAULT, 'done'), { recursive: true });
    
    obsidianWatcher = chokidar.watch(
      `${CONFIG.OBSIDIAN_VAULT}/**/*.md`,
      {
        persistent: true,
        ignoreInitial: true,
        ignorePattern: CONFIG.WATCHER_IGNORE_PATTERNS,
        awaitWriteFinish: {
          stabilityThreshold: 2000,
          pollInterval: 100
        }
      }
    );
    
    obsidianWatcher
      .on('add', async (filepath) => {
        console.log(`üìÑ Obsidian file added: ${path.relative(CONFIG.OBSIDIAN_VAULT, filepath)}`);
        await handleObsidianFileChange(filepath, 'add');
      })
      .on('change', async (filepath) => {
        console.log(`üìù Obsidian file changed: ${path.relative(CONFIG.OBSIDIAN_VAULT, filepath)}`);
        await handleObsidianFileChange(filepath, 'change');
      })
      .on('unlink', async (filepath) => {
        console.log(`üóëÔ∏è Obsidian file deleted: ${path.relative(CONFIG.OBSIDIAN_VAULT, filepath)}`);
        await handleObsidianFileChange(filepath, 'unlink');
      });
    
    console.log('üëÄ Obsidian file watcher initialized');
    
    // Also watch for backlink references in entire vault
    const backlinkWatcher = chokidar.watch(
      `${CONFIG.OBSIDIAN_VAULT_FULL}/**/*.md`,
      {
        persistent: true,
        ignoreInitial: true,
        ignorePattern: [...CONFIG.WATCHER_IGNORE_PATTERNS, `${CONFIG.OBSIDIAN_VAULT}/**/*.md`],
        awaitWriteFinish: {
          stabilityThreshold: 3000,
          pollInterval: 200
        }
      }
    );
    
    backlinkWatcher.on('change', async (filepath) => {
      await scanBacklinks();
    });
    
    console.log('üîó Backlink scanner initialized');
    
  } catch (err) {
    console.warn('Could not initialize file watcher:', err.message);
  }
}

async function handleObsidianFileChange(filepath, eventType) {
  const filename = path.basename(filepath);
  const taskId = filename.replace('.md', '');
  
  // Debounce rapid changes
  const now = Date.now();
  if (lastObsidianUpdate && (now - lastObsidianUpdate) < 2000) {
    return; // Skip if less than 2 seconds since last update
  }
  lastObsidianUpdate = now;
  
  try {
    if (eventType === 'unlink') {
      // File deleted in Obsidian - soft delete in tasks
      const tasks = await getTasks();
      const task = tasks.find(t => t.obsidianPath === filepath);
      if (task) {
        task.status = 'deleted';
        task.updated = new Date().toISOString();
        await saveTasks(tasks);
        
        await logEvent({
          type: 'system',
          severity: 'warning',
          title: 'Task deleted in Obsidian',
          description: `Task "${task.title}" was deleted in Obsidian`,
          metadata: { taskId: task.id, filepath }
        });
        
        broadcastUpdate('task-deleted', { taskId: task.id });
      }
    } else {
      // File added or changed - pull changes
      // await pullFromObsidian(); // DISABLED
      broadcastUpdate('tasks-refreshed', { timestamp: new Date().toISOString() });
      
      await logEvent({
        type: 'system',
        severity: 'info',
        title: `Task ${eventType === 'add' ? 'created' : 'updated'} in Obsidian`,
        description: `Synced from: ${path.relative(CONFIG.OBSIDIAN_VAULT, filepath)}`,
        metadata: { taskId, eventType }
      });
    }
  } catch (err) {
    console.error('Error handling Obsidian file change:', err);
    await logEvent({
      type: 'system',
      severity: 'error',
      title: 'Obsidian sync error',
      description: err.message,
      metadata: { filepath, eventType, error: err.stack }
    });
  }
}

// Extract backlinks from Obsidian files
async function scanBacklinks() {
  try {
    const tasks = await getTasks();
    const backlinks = new Map(); // taskId -> Set of backlinks
    
    // Scan all task files for backlink references
    for (const task of tasks) {
      if (task.obsidianPath) {
        try {
          const content = await fs.readFile(task.obsidianPath, 'utf8');
          // Extract [[WikiLinks]] and regular links
          const wikiLinkPattern = /\[\[([^\]]+)\]\]/g;
          const markdownLinkPattern = /\[([^\]]+)\]\(([^)]+)\)/g;
          
          const backlinksSet = new Set();
          let match;
          
          while ((match = wikiLinkPattern.exec(content)) !== null) {
            const linkTarget = match[1].split('|')[0].trim();
            if (linkTarget !== task.title) {
              backlinksSet.add(`[[${linkTarget}]]`);
            }
          }
          
          while ((match = markdownLinkPattern.exec(content)) !== null) {
            const linkTarget = match[2];
            if (linkTarget && !linkTarget.includes(task.id)) {
              backlinksSet.add(`[${match[1]}](${linkTarget})`);
            }
          }
          
          if (backlinksSet.size > 0) {
            backlinks.set(task.id, Array.from(backlinksSet));
          }
        } catch (err) {
          // File might not exist yet
        }
      }
    }
    
    // Update tasks with backlinks
    if (backlinks.size > 0) {
      const tasksData = await getTasks();
      let updated = false;
      
      for (const [taskId, taskBacklinks] of backlinks) {
        const task = tasksData.find(t => t.id === taskId);
        if (task && JSON.stringify(task.backlinks) !== JSON.stringify(taskBacklinks)) {
          task.backlinks = taskBacklinks;
          task.updated = new Date().toISOString();
          updated = true;
        }
      }
      
      if (updated) {
        await saveTasks(tasksData);
        console.log(`üîó Scanned and updated ${backlinks.size} task backlinks`);
      }
    }
  } catch (err) {
    console.error('Error scanning backlinks:', err);
  }
}

// ============================================
// ENHANCED CONFLICT RESOLUTION
// ============================================

async function resolveConflict(localTask, obsidianTask, filepath) {
  const localUpdated = new Date(localTask.updated || 0);
  const obsidianUpdated = new Date(obsidianTask.updated || 0);
  
  // If timestamps are within 5 seconds, treat as conflict
  const timeDiff = Math.abs(localUpdated - obsidianUpdated);
  
  if (timeDiff < 5000) {
    // Create conflict file
    const conflictPath = filepath.replace('.md', `.conflict-${Date.now()}.md`);
    const conflictContent = `---
conflict: true
localTask: ${JSON.stringify(localTask, null, 2)}
obsidianTask: ${JSON.stringify(obsidianTask, null, 2)}
resolved: false
created: ${new Date().toISOString()}
---

# Conflict: ${localTask.title}

This task was modified simultaneously in both the dashboard and Obsidian.

## Local Version (Dashboard)
- Updated: ${localTask.updated}
- Status: ${localTask.status}

## Obsidian Version
- Updated: ${obsidianTask.updated}
- Status: ${obsidianTask.status}

Please resolve this conflict manually.
`;
    await fs.writeFile(conflictPath, conflictContent, 'utf8');
    
    await logEvent({
      type: 'system',
      severity: 'warning',
      title: 'Sync conflict detected',
      description: `Conflict file created: ${path.basename(conflictPath)}`,
      metadata: { localTaskId: localTask.id, conflictPath, timeDiff }
    });
    
    return { resolved: false, conflictPath, strategy: 'manual' };
  }
  
  // Otherwise, most recent wins
  if (obsidianUpdated > localUpdated) {
    return { resolved: true, winner: 'obsidian', strategy: 'timestamp' };
  } else {
    return { resolved: true, winner: 'local', strategy: 'timestamp' };
  }
}

// ============================================
// MIDDLEWARE
// ============================================

app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use('/outputs', express.static(CONFIG.OUTPUTS_DIR));
app.use('/thumbnails', express.static(CONFIG.THUMBNAILS_DIR));

// Serve dashboard HTML at root
app.get('/', async (req, res) => {
  try {
    const dashboardPath = path.join(CONFIG.BASE_DIR, 'agent-dashboard.html');
    const html = await fs.readFile(dashboardPath, 'utf8');
    res.setHeader('Content-Type', 'text/html');
    res.send(html);
  } catch (err) {
    res.status(500).send('Dashboard not found');
  }
});

// File upload configuration
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const today = new Date().toISOString().split('T')[0];
    const dateDir = path.join(CONFIG.OUTPUTS_DIR, today);
    const typeDir = getFileTypeDir(file.mimetype);
    const uploadPath = path.join(dateDir, typeDir);
    
    try {
      await fs.mkdir(uploadPath, { recursive: true });
      cb(null, uploadPath);
    } catch (err) {
      cb(err);
    }
  },
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
  fileFilter: (req, file, cb) => {
    // Accept all files, can add restrictions here
    cb(null, true);
  }
});

function getFileTypeDir(mimetype) {
  if (mimetype.startsWith('image/')) return 'screenshots';
  if (mimetype.startsWith('text/') || mimetype.includes('javascript') || mimetype.includes('json') || mimetype.includes('markdown')) return 'code';
  return 'uploads';
}

// ============================================
// STORAGE LAYER
// ============================================

async function readJson(filePath) {
  try {
    const data = await fs.readFile(filePath, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    }
    throw err;
  }
}

async function writeJson(filePath, data) {
  await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8');
}

async function getTasks() {
  const data = await readJson(CONFIG.TASKS_FILE);
  return data?.tasks || [];
}

async function saveTasks(tasks) {
  await writeJson(CONFIG.TASKS_FILE, {
    version: '1.0',
    lastUpdated: new Date().toISOString(),
    tasks
  });
}

async function getFiles() {
  const data = await readJson(CONFIG.FILES_FILE);
  return data?.files || [];
}

async function saveFiles(files) {
  await writeJson(CONFIG.FILES_FILE, {
    version: '1.0',
    lastUpdated: new Date().toISOString(),
    files
  });
}

async function getEvents() {
  const data = await readJson(CONFIG.EVENTS_FILE);
  return data?.events || [];
}

async function saveEvents(events) {
  await writeJson(CONFIG.EVENTS_FILE, {
    version: '1.0',
    lastUpdated: new Date().toISOString(),
    events
  });
}

// ============================================
// REPORTS & ARCHIVE FUNCTIONS
// ============================================

async function getReports() {
  const data = await readJson(CONFIG.REPORTS_FILE);
  return data?.reports || [];
}

async function saveReports(reports) {
  await writeJson(CONFIG.REPORTS_FILE, {
    version: '1.0',
    lastUpdated: new Date().toISOString(),
    reports
  });
}

async function createReport(task, completionSummary, prompts = []) {
  const reports = await getReports();
  
  const report = {
    id: `report-${task.id}`,
    taskId: task.id,
    title: task.title,
    description: task.description,
    priority: task.priority,
    tags: task.tags || [],
    agentType: task.agentType,
    planFirst: task.planFirst,
    created: task.created,
    completed: task.completed,
    archivedAt: new Date().toISOString(),
    // Execution summary
    durationMinutes: completionSummary?.durationMinutes || 0,
    cost: completionSummary?.cost || 0,
    stepsCompleted: completionSummary?.stepsCompleted || 0,
    totalSteps: completionSummary?.totalSteps || 0,
    whatWasAccomplished: completionSummary?.whatWasAccomplished || '',
    outputFiles: completionSummary?.outputFiles || [],
    outputLocation: completionSummary?.outputLocation || '',
    finderPath: completionSummary?.finderPath || '',
    urls: completionSummary?.urls || [],
    // Agent prompts used during execution
    agentPrompts: prompts,
    // Keep full copies
    taskSnapshot: { ...task },
    completionSnapshot: { ...completionSummary }
  };
  
  reports.push(report);
  await saveReports(reports);
  
  await logEvent({
    type: 'task',
    severity: 'info',
    title: 'Report created',
    description: `Report generated for completed task: ${task.title}`,
    metadata: { reportId: report.id, taskId: task.id, promptsCount: prompts.length }
  });
  
  return report;
}

async function getArchivedTasks() {
  const data = await readJson(CONFIG.ARCHIVE_FILE);
  return data?.archived || [];
}

async function saveArchivedTasks(archived) {
  await writeJson(CONFIG.ARCHIVE_FILE, {
    version: '1.0',
    lastUpdated: new Date().toISOString(),
    archived
  });
}

async function archiveTask(task) {
  const archived = await getArchivedTasks();
  
  const archivedTask = {
    ...task,
    archivedAt: new Date().toISOString(),
    originalStatus: task.status
  };
  
  archived.push(archivedTask);
  await saveArchivedTasks(archived);
  
  // Remove from active tasks
  const tasks = await getTasks();
  const filtered = tasks.filter(t => t.id !== task.id);
  await saveTasks(filtered);
  
  await logEvent({
    type: 'task',
    severity: 'info',
    title: 'Task archived',
    description: `Task archived: ${task.title}`,
    metadata: { taskId: task.id }
  });
  
  return archivedTask;
}

async function restoreTaskFromArchive(taskId) {
  const archived = await getArchivedTasks();
  const taskIndex = archived.findIndex(t => t.id === taskId);
  
  if (taskIndex === -1) {
    throw new Error('Task not found in archive');
  }
  
  const task = archived[taskIndex];
  delete task.archivedAt;
  delete task.originalStatus;
  task.status = 'backlog';
  task.updated = new Date().toISOString();
  
  // Add back to active tasks
  const tasks = await getTasks();
  tasks.push(task);
  await saveTasks(tasks);
  
  // Remove from archive
  archived.splice(taskIndex, 1);
  await saveArchivedTasks(archived);
  
  await logEvent({
    type: 'task',
    severity: 'info',
    title: 'Task restored',
    description: `Task restored from archive: ${task.title}`,
    metadata: { taskId: task.id }
  });
  
  return task;
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

function generateId() {
  return uuidv4();
}

function calculateSuggestionScore(task, options = {}) {
  const { explicitContext, timeContext, agentContext } = options;
  
  let score = 0;
  
  // 1. Priority Score (35% weight)
  const priorityScore = PRIORITY_WEIGHTS[task.priority] || 25;
  score += (priorityScore / 100) * 35;
  
  // 2. Urgency Score (25% weight)
  let urgencyScore = 10; // No due date
  if (task.dueDate) {
    const now = new Date();
    const due = new Date(task.dueDate);
    const daysUntilDue = Math.ceil((due - now) / (1000 * 60 * 60 * 24));
    
    if (daysUntilDue < 0) urgencyScore = 100; // Overdue
    else if (daysUntilDue === 0) urgencyScore = 90; // Due today
    else if (daysUntilDue === 1) urgencyScore = 70; // Due tomorrow
    else if (daysUntilDue <= 3) urgencyScore = 50; // Due this week
    else if (daysUntilDue <= 7) urgencyScore = 30; // Due soon
    else urgencyScore = 15; // Due later
  }
  score += (urgencyScore / 100) * 25;
  
  // 3. Blocker Score (20% weight)
  // Check if other tasks depend on this one (simulated via backlinks)
  let blockerScore = 0;
  if (task.backlinks && task.backlinks.length > 0) {
    blockerScore = Math.min(task.backlinks.length * 30, 100);
  }
  score += (blockerScore / 100) * 20;
  
  // 4. Context Score (10% weight)
  let contextScore = 50; // Neutral baseline
  
  // Time-based context matching
  if (timeContext) {
    const preferredTypes = timeContext.preferredTaskTypes || [];
    
    // Check if task matches current time of day
    if (task.status === 'today' && 
        (timeContext.context === 'morning' || timeContext.context === 'morning-early')) {
      contextScore += 20;
    }
    if (task.status === 'tomorrow' && 
        (timeContext.context === 'evening' || timeContext.context === 'night')) {
      contextScore += 20;
    }
    
    // Energy-based task matching
    if (task.estimatedMinutes) {
      const highEnergyTasks = ['deep-work', 'creative', 'complex'];
      const lowEnergyTasks = ['admin', 'quick-wins', 'light'];
      
      if (timeContext.energy === 'high' && 
          highEnergyTasks.some(t => preferredTypes.includes(t))) {
        contextScore += 15;
      }
      if ((timeContext.energy === 'low' || timeContext.energy === 'very-low') && 
          lowEnergyTasks.some(t => preferredTypes.includes(t))) {
        contextScore += 15;
      }
    }
  }
  
  // Explicit context override
  if (explicitContext) {
    switch (explicitContext.toLowerCase()) {
      case 'morning':
      case 'deep-work':
        if (task.estimatedMinutes && task.estimatedMinutes >= 60) contextScore += 20;
        break;
      case 'quick-wins':
        if (!task.estimatedMinutes || task.estimatedMinutes <= 30) contextScore += 25;
        break;
      case 'afternoon':
        if (task.status === 'today') contextScore += 15;
        break;
    }
  }
  
  score += (Math.min(contextScore, 100) / 100) * 10;
  
  // 5. Momentum Score (10% weight)
  let momentumScore = 50; // Neutral
  
  // Recently created tasks get a boost
  const created = new Date(task.created);
  const now = new Date();
  const hoursSinceCreation = (now - created) / (1000 * 60 * 60);
  
  if (hoursSinceCreation < 2) {
    momentumScore += 30; // Fresh tasks
  } else if (hoursSinceCreation < 24) {
    momentumScore += 15;
  }
  
  // Auto-extracted tasks from memory/conversation
  if (task.metadata?.autoExtracted) {
    momentumScore += 20; // Recent mentions
  }
  
  // Source context indicates recent relevance
  if (task.sourceContext?.startsWith('memory:') || 
      task.sourceContext?.startsWith('conversation:')) {
    momentumScore += 15;
  }
  
  score += (Math.min(momentumScore, 100) / 100) * 10;
  
  // Status penalty for done tasks
  if (task.status === 'done' || task.status === 'deleted') {
    score = 0;
  }
  
  return Math.min(Math.round(score), 100);
}

function buildTaskMarkdown(task) {
  const frontmatter = {
    id: task.id,
    title: task.title,
    priority: task.priority,
    status: task.status,
    created: task.created,
    updated: task.updated,
    completed: task.completed || null,
    dueDate: task.dueDate || null,
    tags: task.tags || [],
    assignee: task.assignee || 'claw-machine',
    estimatedMinutes: task.estimatedMinutes || null,
    actualMinutes: task.actualMinutes || null,
    files: task.files || [],
    sourceContext: task.sourceContext || null
  };
  
  const content = `# ${task.title}\n\n` +
    (task.description ? `## Description\n\n${task.description}\n\n` : '') +
    (task.tags?.length ? `**Tags:** ${task.tags.map(t => '#' + t).join(' ')}\n\n` : '') +
    (task.dueDate ? `**Due:** ${new Date(task.dueDate).toLocaleDateString()}\n\n` : '') +
    (task.backlinks?.length ? `## Backlinks\n\n${task.backlinks.map(l => `- ${l}`).join('\n')}\n\n` : '');
  
  return matter.stringify(content, frontmatter);
}

async function parseObsidianTask(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf8');
    const parsed = matter(content);
    return {
      ...parsed.data,
      description: parsed.content.replace(/^# .+\n\n/, '').trim()
    };
  } catch (err) {
    console.error(`Error parsing ${filePath}:`, err.message);
    return null;
  }
}

// ============================================
// TASK ENDPOINTS
// ============================================

// GET /tasks - Retrieve all tasks with optional filters
app.get('/api/v1/tasks', async (req, res) => {
  try {
    const { status, priority, tags, search, limit = 100, offset = 0 } = req.query;
    
    let tasks = await getTasks();
    
    // Apply filters
    if (status) {
      tasks = tasks.filter(t => t.status === status);
    }
    if (priority) {
      tasks = tasks.filter(t => t.priority === priority);
    }
    if (tags) {
      const tagList = tags.split(',');
      tasks = tasks.filter(t => tagList.some(tag => t.tags?.includes(tag)));
    }
    if (search) {
      const searchLower = search.toLowerCase();
      tasks = tasks.filter(t => 
        t.title.toLowerCase().includes(searchLower) ||
        t.description?.toLowerCase().includes(searchLower)
      );
    }
    
    // Sort by status order, then priority, then updated desc
    tasks.sort((a, b) => {
      const statusA = STATUS_ORDER.indexOf(a.status);
      const statusB = STATUS_ORDER.indexOf(b.status);
      if (statusA !== statusB) return statusA - statusB;
      
      const prioA = PRIORITY_WEIGHTS[a.priority] || 0;
      const prioB = PRIORITY_WEIGHTS[b.priority] || 0;
      if (prioA !== prioB) return prioB - prioA;
      
      return new Date(b.updated) - new Date(a.updated);
    });
    
    const total = tasks.length;
    tasks = tasks.slice(parseInt(offset), parseInt(offset) + parseInt(limit));
    
    res.json({ tasks, total, offset: parseInt(offset), limit: parseInt(limit) });
  } catch (err) {
    console.error('Error getting tasks:', err);
    res.status(500).json({ error: 'Failed to retrieve tasks' });
  }
});

// GET /tasks/:id - Get single task
app.get('/api/v1/tasks/:id', async (req, res) => {
  try {
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === req.params.id);
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json(task);
  } catch (err) {
    console.error('Error getting task:', err);
    res.status(500).json({ error: 'Failed to retrieve task' });
  }
});

// POST /tasks - Create new task
app.post('/api/v1/tasks', async (req, res) => {
  try {
    const { title, description, priority = 'P2', status = 'backlog', dueDate, tags, sourceContext, estimatedMinutes } = req.body;
    
    if (!title || title.trim().length === 0) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    const now = new Date().toISOString();
    const task = {
      id: generateId(),
      title: title.trim().substring(0, 200),
      description: description?.trim() || null,
      priority,
      status,
      created: now,
      updated: now,
      completed: null,
      dueDate: dueDate || null,
      tags: tags || [],
      assignee: 'claw-machine',
      estimatedMinutes: estimatedMinutes || null,
      actualMinutes: null,
      files: [],
      obsidianPath: null,
      sourceContext: sourceContext || null,
      backlinks: [],
      metadata: {
        createdBy: 'user',
        suggestionScore: null,
        lastSuggested: null
      }
    };
    
    const tasks = await getTasks();
    tasks.push(task);
    await saveTasks(tasks);
    
    // Log event
    await logEvent({
      type: 'task',
      severity: 'info',
      title: 'Task created',
      description: `Created task: ${task.title}`,
      metadata: { taskId: task.id }
    });
    
    // Push to Obsidian
    // await pushToObsidian(task); // DISABLED
    
    res.status(201).json(task);
  } catch (err) {
    console.error('Error creating task:', err);
    res.status(500).json({ error: 'Failed to create task' });
  }
});

// PATCH /tasks/:id - Update task (partial)
app.patch('/api/v1/tasks/:id', async (req, res) => {
  try {
    const tasks = await getTasks();
    const index = tasks.findIndex(t => t.id === req.params.id);
    
    if (index === -1) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    const allowedFields = ['title', 'description', 'priority', 'status', 'dueDate', 'tags', 'estimatedMinutes', 'actualMinutes', 'files', 'backlinks', 'planFirst', 'agentType', 'executionStatus', 'completionSummary'];
    const updates = {};
    
    for (const field of allowedFields) {
      if (req.body[field] !== undefined) {
        updates[field] = req.body[field];
      }
    }
    
    // Handle completion
    if (updates.status === 'done' && tasks[index].status !== 'done') {
      updates.completed = new Date().toISOString();
    } else if (updates.status && updates.status !== 'done') {
      updates.completed = null;
    }
    
    tasks[index] = {
      ...tasks[index],
      ...updates,
      updated: new Date().toISOString()
    };
    
    await saveTasks(tasks);
    // await pushToObsidian(tasks[index]); // DISABLED
    
    res.json(tasks[index]);
  } catch (err) {
    console.error('Error updating task:', err);
    res.status(500).json({ error: 'Failed to update task' });
  }
});

// POST /tasks/:id/move - Move task to different status
app.post('/api/v1/tasks/:id/move', async (req, res) => {
  try {
    const { status } = req.body;
    
    if (!STATUS_ORDER.includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === req.params.id);
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    const oldStatus = task.status;
    task.status = status;
    task.updated = new Date().toISOString();
    
    if (status === 'done' && oldStatus !== 'done') {
      task.completed = new Date().toISOString();
    } else if (status !== 'done') {
      task.completed = null;
    }
    
    await saveTasks(tasks);
    // await pushToObsidian(task); // DISABLED
    
    await logEvent({
      type: 'task',
      severity: 'info',
      title: 'Task moved',
      description: `Moved "${task.title}" from ${oldStatus} to ${status}`,
      metadata: { taskId: task.id, oldStatus, newStatus: status }
    });
    
    res.json(task);
  } catch (err) {
    console.error('Error moving task:', err);
    res.status(500).json({ error: 'Failed to move task' });
  }
});

// POST /tasks/clear-completed - Move all completed tasks to archive
app.post('/api/v1/tasks/clear-completed', async (req, res) => {
  try {
    const tasks = await getTasks();
    const completedTasks = tasks.filter(t => t.status === 'done' && t.completionSummary);
    
    if (completedTasks.length === 0) {
      return res.json({ success: true, cleared: 0, message: 'No completed tasks to clear' });
    }
    
    // Archive completed tasks
    const archived = [];
    for (const task of completedTasks) {
      try {
        await archiveTask(task);
        archived.push(task.id);
      } catch (err) {
        console.error(`Error archiving task ${task.id}:`, err);
      }
    }
    
    await logEvent({
      type: 'task',
      severity: 'info',
      title: 'Cleared completed tasks',
      description: `Archived ${archived.length} completed tasks`,
      metadata: { cleared: archived.length, taskIds: archived }
    });
    
    res.json({ success: true, cleared: archived.length, taskIds: archived });
  } catch (err) {
    console.error('Error clearing completed tasks:', err);
    res.status(500).json({ error: 'Failed to clear completed tasks' });
  }
});

// DELETE /tasks/:id - Delete task
app.delete('/api/v1/tasks/:id', async (req, res) => {
  try {
    const tasks = await getTasks();
    const index = tasks.findIndex(t => t.id === req.params.id);
    
    if (index === -1) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    const task = tasks[index];
    tasks.splice(index, 1);
    await saveTasks(tasks);
    
    // Delete from Obsidian
    if (task.obsidianPath) {
      try {
        await fs.unlink(task.obsidianPath);
      } catch (err) {
        console.warn('Could not delete Obsidian file:', err.message);
      }
    }
    
    await logEvent({
      type: 'task',
      severity: 'info',
      title: 'Task deleted',
      description: `Deleted task: ${task.title}`,
      metadata: { taskId: task.id }
    });
    
    res.status(204).send();
  } catch (err) {
    console.error('Error deleting task:', err);
    res.status(500).json({ error: 'Failed to delete task' });
  }
});

// ============================================
// INTELLIGENCE LAYER - CONTEXT DETECTION
// ============================================

function getTimeContext() {
  const hour = new Date().getHours();
  const day = new Date().getDay();
  const isWeekend = day === 0 || day === 6;
  
  if (hour >= 6 && hour < 9) {
    return {
      context: 'morning-early',
      energy: 'building',
      preferredTaskTypes: ['quick-wins', 'planning', 'email'],
      workStyle: 'starting'
    };
  } else if (hour >= 9 && hour < 12) {
    return {
      context: 'morning',
      energy: 'high',
      preferredTaskTypes: ['deep-work', 'creative', 'complex'],
      workStyle: 'focused'
    };
  } else if (hour >= 12 && hour < 14) {
    return {
      context: 'lunch',
      energy: 'medium',
      preferredTaskTypes: ['light', 'admin', 'review'],
      workStyle: 'transitional'
    };
  } else if (hour >= 14 && hour < 17) {
    return {
      context: 'afternoon',
      energy: 'medium-high',
      preferredTaskTypes: ['implementation', 'meetings', 'collaboration'],
      workStyle: 'productive'
    };
  } else if (hour >= 17 && hour < 20) {
    return {
      context: 'evening',
      energy: 'low-medium',
      preferredTaskTypes: ['wrapping-up', 'admin', 'quick-wins'],
      workStyle: 'closing'
    };
  } else if (hour >= 20 && hour < 23) {
    return {
      context: 'night',
      energy: 'low',
      preferredTaskTypes: ['light', 'review', 'planning'],
      workStyle: 'relaxed'
    };
  } else {
    return {
      context: 'late-night',
      energy: 'very-low',
      preferredTaskTypes: ['minimal', 'review'],
      workStyle: 'wind-down'
    };
  }
}

function getAgentContext() {
  // Try to read agent state from memory
  const memoryDir = path.join(CONFIG.BASE_DIR, 'memory');
  const today = new Date().toISOString().split('T')[0];
  const memoryFile = path.join(memoryDir, `${today}.md`);
  
  return {
    time: getTimeContext(),
    recentTasks: [], // Would be populated from recent history
    activeProject: null, // Would detect from current work
    availableTime: 60, // Default 60 minutes
    isThinking: false // Would detect from agent state
  };
}

// ============================================
// INTELLIGENCE LAYER - MEMORY FILE PARSER
// ============================================

async function parseMemoryFiles() {
  try {
    const memoryDir = path.join(CONFIG.BASE_DIR, 'memory');
    
    try {
      await fs.mkdir(memoryDir, { recursive: true });
    } catch (err) {
      // Directory exists
    }
    
    // Parse today's and yesterday's memory files
    const tasks = [];
    const patterns = [
      { regex: /TODO:\s*(.+)/gi, priority: 'P2', source: 'TODO' },
      { regex: /need to\s+(.+)/gi, priority: 'P1', source: 'need-to' },
      { regex: /should\s+(.+)/gi, priority: 'P2', source: 'should' },
      { regex: /\[ \]\s*(.+)/gi, priority: 'P2', source: 'checkbox' },
      { regex: /remind me to\s+(.+)/gi, priority: 'P2', source: 'reminder' },
      { regex: /action item[:\s]+(.+)/gi, priority: 'P1', source: 'action-item' },
      { regex: /important[:\s]+(.+)/gi, priority: 'P0', source: 'important' }
    ];
    
    for (let dayOffset = 0; dayOffset <= 1; dayOffset++) {
      const date = new Date();
      date.setDate(date.getDate() - dayOffset);
      const dateStr = date.toISOString().split('T')[0];
      const memFile = path.join(memoryDir, `${dateStr}.md`);
      
      try {
        const content = await fs.readFile(memFile, 'utf8');
        const lines = content.split('\n');
        
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          
          for (const pattern of patterns) {
            let match;
            pattern.regex.lastIndex = 0; // Reset regex state
            
            while ((match = pattern.regex.exec(line)) !== null) {
              const title = match[1].trim();
              if (title.length > 3 && title.length < 200) {
                tasks.push({
                  title,
                  priority: pattern.priority,
                  status: 'backlog',
                  sourceContext: `memory:${dateStr}:line:${lineNum + 1}`,
                  description: `Extracted from: ${pattern.source}`,
                  metadata: {
                    autoExtracted: true,
                    extractionPattern: pattern.source
                  }
                });
              }
            }
          }
        }
      } catch (err) {
        // File doesn't exist, skip
      }
    }
    
    return tasks;
  } catch (err) {
    console.error('Error parsing memory files:', err);
    return [];
  }
}

async function parseConversationMentions() {
  // Look for conversation mentions in events/logs
  try {
    const events = await getEvents();
    const mentions = [];
    
    const mentionPatterns = [
      /@claw[- ]?machine[:\s]+(.+)/gi,
      /agent[:\s]+(.+)/gi,
      /can you\s+(.+)/gi,
      /please\s+(.+)/gi
    ];
    
    for (const event of events.slice(0, 100)) {
      if (event.description) {
        for (const pattern of mentionPatterns) {
          let match;
          pattern.lastIndex = 0;
          
          while ((match = pattern.exec(event.description)) !== null) {
            mentions.push({
              title: match[1].trim(),
              sourceContext: `conversation:${event.id}`,
              detectedIn: event.type
            });
          }
        }
      }
    }
    
    return mentions;
  } catch (err) {
    console.error('Error parsing conversation mentions:', err);
    return [];
  }
}

// ============================================
// SUGGESTION ENDPOINTS
// ============================================

app.get('/api/v1/suggestions/next', async (req, res) => {
  try {
    const { context: explicitContext } = req.query;
    const tasks = await getTasks();
    const agentContext = getAgentContext();
    const timeContext = agentContext.time;
    
    // Filter out completed tasks and score each
    const availableTasks = tasks
      .filter(t => t.status !== 'done' && t.status !== 'deleted')
      .map(task => ({
        task,
        score: calculateSuggestionScore(task, {
          explicitContext: explicitContext || timeContext.context,
          timeContext,
          agentContext
        })
      }))
      .filter(item => item.score > 0)
      .sort((a, b) => b.score - a.score);
    
    if (availableTasks.length === 0) {
      return res.json({
        task: null,
        score: 0,
        reasoning: 'No tasks available for suggestions',
        alternatives: []
      });
    }
    
    const top = availableTasks[0];
    const alternatives = availableTasks.slice(1, 4).map(item => ({
      task: item.task,
      score: item.score,
      reasoning: getReasoning(item.task, item.score, timeContext)
    }));
    
    res.json({
      task: top.task,
      score: top.score,
      reasoning: getReasoning(top.task, top.score, timeContext),
      alternatives,
      context: {
        time: timeContext.context,
        energy: timeContext.energy,
        workStyle: timeContext.workStyle
      }
    });
  } catch (err) {
    console.error('Error getting suggestion:', err);
    res.status(500).json({ error: 'Failed to get suggestion' });
  }
});

app.get('/api/v1/suggestions/batch', async (req, res) => {
  try {
    const { count = 3, context } = req.query;
    const limit = Math.min(parseInt(count) || 3, 10);
    const agentContext = getAgentContext();
    
    const tasks = await getTasks();
    
    const suggestions = tasks
      .filter(t => t.status !== 'done' && t.status !== 'deleted')
      .map(task => ({
        task,
        score: calculateSuggestionScore(task, {
          explicitContext: context || agentContext.time.context,
          timeContext: agentContext.time,
          agentContext
        })
      }))
      .filter(item => item.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit)
      .map(item => ({
        task: item.task,
        score: item.score,
        reasoning: getReasoning(item.task, item.score, agentContext.time)
      }));
    
    res.json({
      suggestions,
      generated: new Date().toISOString(),
      context: agentContext.time
    });
  } catch (err) {
    console.error('Error getting batch suggestions:', err);
    res.status(500).json({ error: 'Failed to get suggestions' });
  }
});

// POST /suggestions/extract - Extract tasks from memory/conversations
app.post('/api/v1/suggestions/extract', async (req, res) => {
  try {
    const { type = 'all' } = req.body;
    
    const extractedTasks = [];
    
    if (type === 'all' || type === 'memory') {
      const memoryTasks = await parseMemoryFiles();
      extractedTasks.push(...memoryTasks);
    }
    
    if (type === 'all' || type === 'conversation') {
      const conversationMentions = await parseConversationMentions();
      extractedTasks.push(...conversationMentions.map(m => ({
        title: m.title,
        priority: 'P2',
        status: 'backlog',
        sourceContext: m.sourceContext,
        description: `Mentioned in ${m.detectedIn}`,
        metadata: { autoExtracted: true, extractionType: 'conversation' }
      })));
    }
    
    // Deduplicate by title
    const seen = new Set();
    const uniqueTasks = extractedTasks.filter(t => {
      const key = t.title.toLowerCase().trim();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
    
    res.json({
      extracted: uniqueTasks,
      count: uniqueTasks.length,
      types: type === 'all' ? ['memory', 'conversation'] : [type]
    });
  } catch (err) {
    console.error('Error extracting suggestions:', err);
    res.status(500).json({ error: 'Failed to extract suggestions' });
  }
});

// GET /suggestions/context - Get current context
app.get('/api/v1/suggestions/context', async (req, res) => {
  const timeContext = getTimeContext();
  const agentContext = getAgentContext();
  
  res.json({
    time: timeContext,
    agent: agentContext,
    timestamp: new Date().toISOString()
  });
});

function getReasoning(task, score, timeContext = null) {
  const reasons = [];
  
  if (task.priority === 'P0') reasons.push('Critical priority');
  else if (task.priority === 'P1') reasons.push('High priority');
  else if (task.priority === 'P2') reasons.push('Medium priority');
  else reasons.push('Low priority');
  
  if (task.dueDate) {
    const due = new Date(task.dueDate);
    const now = new Date();
    const days = Math.ceil((due - now) / (1000 * 60 * 60 * 24));
    if (days < 0) reasons.push('Overdue');
    else if (days === 0) reasons.push('Due today');
    else if (days === 1) reasons.push('Due tomorrow');
    else if (days <= 7) reasons.push(`Due in ${days} days`);
  }
  
  if (task.status === 'today') reasons.push('Scheduled for today');
  if (task.status === 'tomorrow') reasons.push('Scheduled for tomorrow');
  
  // Context-aware reasoning
  if (timeContext && task.estimatedMinutes) {
    const availableMinutes = timeContext.energy === 'high' ? 120 : 
                            timeContext.energy === 'medium-high' ? 90 : 
                            timeContext.energy === 'medium' ? 60 : 30;
    
    if (task.estimatedMinutes <= availableMinutes) {
      reasons.push(`Fits your ${timeContext.energy} energy level`);
    }
  }
  
  if (task.metadata?.autoExtracted) {
    reasons.push('Auto-detected from memory');
  }
  
  return reasons.join(', ');
}

// ============================================
// EVENT ENDPOINTS
// ============================================

async function logEvent({ type, severity, title, description, metadata = {} }) {
  try {
    const events = await getEvents();
    const event = {
      id: generateId(),
      timestamp: new Date().toISOString(),
      type,
      severity,
      title,
      description,
      metadata
    };
    
    events.unshift(event);
    
    // Keep only last 1000 events
    if (events.length > 1000) {
      events.splice(1000);
    }
    
    await saveEvents(events);
  } catch (err) {
    console.error('Error logging event:', err);
  }
}

app.get('/api/v1/events', async (req, res) => {
  try {
    const { since, type, limit = 50 } = req.query;
    
    let events = await getEvents();
    
    if (since) {
      events = events.filter(e => e.timestamp > since);
    }
    
    if (type) {
      events = events.filter(e => e.type === type);
    }
    
    events = events.slice(0, parseInt(limit));
    
    res.json({ events, total: events.length });
  } catch (err) {
    console.error('Error getting events:', err);
    res.status(500).json({ error: 'Failed to retrieve events' });
  }
});

app.post('/api/v1/events', async (req, res) => {
  try {
    const { type, severity = 'info', title, description, metadata } = req.body;
    
    if (!title) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    await logEvent({ type, severity, title, description, metadata });
    
    res.status(201).json({ success: true });
  } catch (err) {
    console.error('Error logging event:', err);
    res.status(500).json({ error: 'Failed to log event' });
  }
});

// ============================================
// REPORTS ENDPOINTS
// ============================================

// GET /reports - List all reports
app.get('/api/v1/reports', async (req, res) => {
  try {
    const { limit = 50, offset = 0 } = req.query;
    const reports = await getReports();
    
    // Sort by archivedAt desc (most recent first)
    const sorted = reports.sort((a, b) => new Date(b.archivedAt) - new Date(a.archivedAt));
    
    const paginated = sorted.slice(parseInt(offset), parseInt(offset) + parseInt(limit));
    
    res.json({
      reports: paginated,
      total: reports.length,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (err) {
    console.error('Error fetching reports:', err);
    res.status(500).json({ error: 'Failed to fetch reports' });
  }
});

// GET /reports/:reportId - Get single report
app.get('/api/v1/reports/:reportId', async (req, res) => {
  try {
    const { reportId } = req.params;
    const reports = await getReports();
    const report = reports.find(r => r.id === reportId);
    
    if (!report) {
      return res.status(404).json({ error: 'Report not found' });
    }
    
    res.json(report);
  } catch (err) {
    console.error('Error fetching report:', err);
    res.status(500).json({ error: 'Failed to fetch report' });
  }
});

// DELETE /reports/:reportId - Delete a report
app.delete('/api/v1/reports/:reportId', async (req, res) => {
  try {
    const { reportId } = req.params;
    const reports = await getReports();
    const index = reports.findIndex(r => r.id === reportId);
    
    if (index === -1) {
      return res.status(404).json({ error: 'Report not found' });
    }
    
    reports.splice(index, 1);
    await saveReports(reports);
    
    res.json({ success: true, deleted: reportId });
  } catch (err) {
    console.error('Error deleting report:', err);
    res.status(500).json({ error: 'Failed to delete report' });
  }
});

// ============================================
// ARCHIVE ENDPOINTS
// ============================================

// GET /archive - List archived tasks
app.get('/api/v1/archive', async (req, res) => {
  try {
    const { limit = 50, offset = 0 } = req.query;
    const archived = await getArchivedTasks();
    
    // Sort by archivedAt desc (most recent first)
    const sorted = archived.sort((a, b) => new Date(b.archivedAt) - new Date(a.archivedAt));
    
    const paginated = sorted.slice(parseInt(offset), parseInt(offset) + parseInt(limit));
    
    res.json({
      archived: paginated,
      total: archived.length,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (err) {
    console.error('Error fetching archive:', err);
    res.status(500).json({ error: 'Failed to fetch archive' });
  }
});

// POST /archive/:taskId/restore - Restore task from archive
app.post('/api/v1/archive/:taskId/restore', async (req, res) => {
  try {
    const { taskId } = req.params;
    const task = await restoreTaskFromArchive(taskId);
    res.json({ success: true, task });
  } catch (err) {
    console.error('Error restoring task:', err);
    res.status(500).json({ error: err.message || 'Failed to restore task' });
  }
});

// DELETE /archive/:taskId - Permanently delete from archive
app.delete('/api/v1/archive/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const archived = await getArchivedTasks();
    const index = archived.findIndex(t => t.id === taskId);
    
    if (index === -1) {
      return res.status(404).json({ error: 'Task not found in archive' });
    }
    
    archived.splice(index, 1);
    await saveArchivedTasks(archived);
    
    res.json({ success: true, deleted: taskId });
  } catch (err) {
    console.error('Error deleting from archive:', err);
    res.status(500).json({ error: 'Failed to delete from archive' });
  }
});

// ============================================
// PLAN ENDPOINTS (Phase 1)
// ============================================

// GET /plans - List all plans with optional filters
app.get('/api/v1/plans', async (req, res) => {
  try {
    const { status, taskId } = req.query;
    
    let plans = await listActivePlans();
    
    if (status) {
      plans = plans.filter(p => p.status === status);
    }
    
    if (taskId) {
      plans = plans.filter(p => p.taskId === taskId);
    }
    
    res.json({ 
      plans, 
      total: plans.length,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error('Error listing plans:', err);
    res.status(500).json({ error: 'Failed to list plans' });
  }
});

// GET /plans/:taskId - Get specific plan
app.get('/api/v1/plans/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const plan = await readPlan(taskId);
    
    if (!plan) {
      return res.status(404).json({ error: 'Plan not found' });
    }
    
    const context = await loadContext(taskId);
    const log = await readLog(taskId);
    
    res.json({
      taskId,
      plan,
      context,
      log,
      exists: true
    });
  } catch (err) {
    console.error('Error getting plan:', err);
    res.status(500).json({ error: 'Failed to get plan' });
  }
});

// POST /plans - Create plan manually
app.post('/api/v1/plans', async (req, res) => {
  try {
    const { taskId, content, context: contextData } = req.body;
    
    if (!taskId || !content) {
      return res.status(400).json({ error: 'taskId and content are required' });
    }
    
    const planPath = await writePlan(taskId, content);
    
    if (contextData) {
      await saveContext(taskId, contextData);
    }
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'Plan created',
      description: `Plan created for task ${taskId}`,
      metadata: { taskId, planPath }
    });
    
    res.status(201).json({
      success: true,
      taskId,
      planPath,
      created: new Date().toISOString()
    });
  } catch (err) {
    console.error('Error creating plan:', err);
    res.status(500).json({ error: 'Failed to create plan' });
  }
});

// PUT /plans/:taskId/approve - Approve plan
app.put('/api/v1/plans/:taskId/approve', async (req, res) => {
  try {
    const { taskId } = req.params;
    
    if (!await planExists(taskId)) {
      return res.status(404).json({ error: 'Plan not found' });
    }
    
    const plan = await readPlan(taskId);
    plan.metadata.status = 'approved';
    plan.metadata.approvedAt = new Date().toISOString();
    
    // Rewrite plan with updated metadata
    const updatedContent = matter.stringify(plan.content, plan.metadata);
    await writePlan(taskId, updatedContent);
    
    await appendLog(taskId, {
      level: 'success',
      message: 'Plan approved',
      details: 'Plan approved and ready for execution'
    });
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'Plan approved',
      description: `Plan for task ${taskId} approved`,
      metadata: { taskId }
    });
    
    res.json({ success: true, taskId, status: 'approved' });
  } catch (err) {
    console.error('Error approving plan:', err);
    res.status(500).json({ error: 'Failed to approve plan' });
  }
});

// PUT /plans/:taskId/complete - Mark complete and archive
app.put('/api/v1/plans/:taskId/complete', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { result, outputLocation } = req.body;
    
    if (!await planExists(taskId)) {
      return res.status(404).json({ error: 'Plan not found' });
    }
    
    await appendLog(taskId, {
      level: 'success',
      message: 'Execution completed',
      details: result || 'Task execution finished',
      output: outputLocation
    });
    
    const archiveDir = await archivePlan(taskId, {
      result,
      outputLocation,
      completedAt: new Date().toISOString()
    });
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'Plan archived',
      description: `Plan for task ${taskId} archived`,
      metadata: { taskId, archiveDir }
    });
    
    res.json({ success: true, taskId, archiveDir });
  } catch (err) {
    console.error('Error completing plan:', err);
    res.status(500).json({ error: 'Failed to complete plan' });
  }
});

// PUT /plans/:taskId/progress - Update step progress
app.put('/api/v1/plans/:taskId/progress', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { stepNumber, status, result } = req.body;
    
    if (!await planExists(taskId)) {
      return res.status(404).json({ error: 'Plan not found' });
    }
    
    if (status === 'completed') {
      await logStepComplete(taskId, stepNumber, result);
    } else if (status === 'started') {
      await appendLog(taskId, {
        level: 'info',
        stepNumber,
        message: `Step ${stepNumber} started`,
        details: result
      });
    } else if (status === 'error') {
      await logError(taskId, result, false);
    }
    
    res.json({ success: true, taskId, stepNumber, status });
  } catch (err) {
    console.error('Error updating plan progress:', err);
    res.status(500).json({ error: 'Failed to update progress' });
  }
});

// GET /plans/:taskId/exists - Check if plan exists
app.get('/api/v1/plans/:taskId/exists', async (req, res) => {
  try {
    const { taskId } = req.params;
    const exists = await planExists(taskId);
    res.json({ taskId, exists });
  } catch (err) {
    console.error('Error checking plan existence:', err);
    res.status(500).json({ error: 'Failed to check plan' });
  }
});

// POST /plans/:taskId/log - Append to execution log
app.post('/api/v1/plans/:taskId/log', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { level, message, details, output, stepNumber, agent } = req.body;
    
    const logPath = await appendLog(taskId, {
      level: level || 'info',
      message,
      details,
      output,
      stepNumber,
      agent
    });
    
    res.json({ success: true, taskId, logPath });
  } catch (err) {
    console.error('Error appending to log:', err);
    res.status(500).json({ error: 'Failed to append log' });
  }
});

// GET /plans/:taskId/log - Read execution log
app.get('/api/v1/plans/:taskId/log', async (req, res) => {
  try {
    const { taskId } = req.params;
    const log = await readLog(taskId);
    
    if (!log) {
      return res.status(404).json({ error: 'Log not found' });
    }
    
    res.json({ taskId, log });
  } catch (err) {
    console.error('Error reading log:', err);
    res.status(500).json({ error: 'Failed to read log' });
  }
});

// DELETE /plans/:taskId - Delete plan
app.delete('/api/v1/plans/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    
    if (!await planExists(taskId)) {
      return res.status(404).json({ error: 'Plan not found' });
    }
    
    const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    const files = await fs.readdir(planDir);
    
    for (const file of files) {
      await fs.unlink(path.join(planDir, file));
    }
    await fs.rmdir(planDir);
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'Plan deleted',
      description: `Plan for task ${taskId} deleted`,
      metadata: { taskId }
    });
    
    res.status(204).send();
  } catch (err) {
    console.error('Error deleting plan:', err);
    res.status(500).json({ error: 'Failed to delete plan' });
  }
});

// ============================================
// FILE ENDPOINTS
// ============================================

async function calculateFileHash(filePath) {
  const buffer = await fs.readFile(filePath);
  return crypto.createHash('sha256').update(buffer).digest('hex');
}

app.post('/api/v1/files/upload', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const { taskId, tags } = req.body;
    
    // Calculate hash for deduplication
    const hash = await calculateFileHash(req.file.path);
    
    // Check for duplicate
    const files = await getFiles();
    const existingFile = files.find(f => f.hash === hash);
    
    let file;
    let isDuplicate = false;
    
    if (existingFile) {
      // Link to task if specified
      isDuplicate = true;
      file = existingFile;
      
      if (taskId) {
        if (!file.taskIds.includes(taskId)) {
          file.taskIds.push(taskId);
          await saveFiles(files);
        }
      }
    } else {
      // Create new file record
      file = {
        id: generateId(),
        filename: req.file.originalname,
        filepath: path.relative(path.join(process.env.HOME, 'Desktop/Claw Creations'), req.file.path),
        mimetype: req.file.mimetype,
        size: req.file.size,
        uploaded: new Date().toISOString(),
        taskIds: taskId ? [taskId] : [],
        thumbnail: null,
        hash,
        tags: tags ? tags.split(',').map(t => t.trim()) : [],
        metadata: {
          width: null,
          height: null,
          generatedBy: null
        }
      };
      
      // Check if image and generate thumbnail
      if (req.file.mimetype.startsWith('image/')) {
        try {
          const sharp = require('sharp');
          const thumbnailPath = path.join(CONFIG.THUMBNAILS_DIR, `${file.id}.jpg`);
          await sharp(req.file.path)
            .resize(200, 200, { fit: 'cover' })
            .jpeg({ quality: 80 })
            .toFile(thumbnailPath);
          
          file.thumbnail = path.relative(path.join(process.env.HOME, 'Desktop/Claw Creations'), thumbnailPath);
          
          // Get dimensions
          const metadata = await sharp(req.file.path).metadata();
          file.metadata.width = metadata.width;
          file.metadata.height = metadata.height;
        } catch (err) {
          console.warn('Could not generate thumbnail:', err.message);
        }
      }
      
      files.push(file);
      await saveFiles(files);
    }
    
    // Link to task if specified and not duplicate
    if (taskId && !isDuplicate) {
      const tasks = await getTasks();
      const task = tasks.find(t => t.id === taskId);
      if (task) {
        if (!task.files.includes(file.id)) {
          task.files.push(file.id);
          await saveTasks(tasks);
          // await pushToObsidian(task); // DISABLED
        }
      }
    }
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: isDuplicate ? 'File duplicate detected' : 'File uploaded',
      description: `${req.file.originalname}${isDuplicate ? ' (duplicate, linked)' : ''}`,
      metadata: { fileId: file.id, taskId, duplicate: isDuplicate }
    });
    
    res.status(201).json({
      file,
      url: `/api/v1/files/${file.id}/view`,
      duplicate: isDuplicate
    });
  } catch (err) {
    console.error('Error uploading file:', err);
    res.status(500).json({ error: 'Failed to upload file' });
  }
});

app.get('/api/v1/files/:id/view', async (req, res) => {
  try {
    const files = await getFiles();
    const file = files.find(f => f.id === req.params.id);
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    const filePath = path.join(process.env.HOME, 'Desktop/Claw Creations', file.filepath);
    res.sendFile(filePath);
  } catch (err) {
    console.error('Error serving file:', err);
    res.status(404).json({ error: 'File not found' });
  }
});

app.get('/api/v1/files', async (req, res) => {
  try {
    const { taskId, tags, mimetype } = req.query;
    
    let files = await getFiles();
    
    if (taskId) {
      files = files.filter(f => f.taskIds.includes(taskId));
    }
    
    if (tags) {
      const tagList = tags.split(',');
      files = files.filter(f => tagList.some(tag => f.tags?.includes(tag)));
    }
    
    if (mimetype) {
      files = files.filter(f => f.mimetype.startsWith(mimetype));
    }
    
    res.json({ files, total: files.length });
  } catch (err) {
    console.error('Error listing files:', err);
    res.status(500).json({ error: 'Failed to list files' });
  }
});

// GET /files/:id - Get file metadata
app.get('/api/v1/files/:id', async (req, res) => {
  try {
    const files = await getFiles();
    const file = files.find(f => f.id === req.params.id);
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    res.json(file);
  } catch (err) {
    console.error('Error getting file:', err);
    res.status(500).json({ error: 'Failed to get file' });
  }
});

// POST /files/link - Link file to task
app.post('/api/v1/files/link', async (req, res) => {
  try {
    const { fileId, taskId } = req.body;
    
    if (!fileId || !taskId) {
      return res.status(400).json({ error: 'fileId and taskId required' });
    }
    
    const files = await getFiles();
    const file = files.find(f => f.id === fileId);
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    // Add task to file's taskIds
    if (!file.taskIds.includes(taskId)) {
      file.taskIds.push(taskId);
      await saveFiles(files);
    }
    
    // Add file to task's files
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === taskId);
    
    if (task) {
      if (!task.files.includes(fileId)) {
        task.files.push(fileId);
        await saveTasks(tasks);
        // await pushToObsidian(task); // DISABLED
      }
    }
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'File linked to task',
      description: `${file.filename} linked to task`,
      metadata: { fileId, taskId }
    });
    
    res.json({ success: true, file, task });
  } catch (err) {
    console.error('Error linking file:', err);
    res.status(500).json({ error: 'Failed to link file' });
  }
});

// POST /files/auto-link - Auto-link from agent output (webhook endpoint)
app.post('/api/v1/files/auto-link', async (req, res) => {
  try {
    const { filepath, filename, taskId, sourceContext, tags, generatedBy } = req.body;
    
    if (!filepath || !filename) {
      return res.status(400).json({ error: 'filepath and filename required' });
    }
    
    // Resolve full path
    const fullPath = filepath.startsWith('/') ? filepath : 
      path.join(process.env.HOME, 'Desktop/Claw Creations', filepath);
    
    // Check if file exists
    try {
      await fs.access(fullPath);
    } catch {
      return res.status(404).json({ error: 'File not found' });
    }
    
    // Calculate hash
    const hash = await calculateFileHash(fullPath);
    const stats = await fs.stat(fullPath);
    
    // Determine mimetype
    const ext = path.extname(filename).toLowerCase();
    const mimetype = getMimeType(ext);
    
    // Check for duplicate
    const files = await getFiles();
    const existingFile = files.find(f => f.hash === hash);
    
    let file;
    
    if (existingFile) {
      file = existingFile;
      // Link to task if specified
      if (taskId && !file.taskIds.includes(taskId)) {
        file.taskIds.push(taskId);
        await saveFiles(files);
      }
    } else {
      // Determine category for file organization
      const category = determineFileCategory(filename, mimetype);
      const today = new Date().toISOString().split('T')[0];
      const destDir = path.join(CONFIG.OUTPUTS_DIR, today, category);
      await fs.mkdir(destDir, { recursive: true });
      
      // Copy file to outputs
      const destPath = path.join(destDir, `${Date.now()}-${filename}`);
      await fs.copyFile(fullPath, destPath);
      
      // Create file record
      file = {
        id: generateId(),
        filename,
        filepath: path.relative(path.join(process.env.HOME, 'Desktop/Claw Creations'), destPath),
        mimetype,
        size: stats.size,
        uploaded: new Date().toISOString(),
        taskIds: taskId ? [taskId] : [],
        thumbnail: null,
        hash,
        tags: tags || [],
        metadata: {
          width: null,
          height: null,
          generatedBy: generatedBy || 'agent'
        }
      };
      
      // Generate thumbnail for images
      if (mimetype.startsWith('image/')) {
        try {
          const sharp = require('sharp');
          const thumbnailPath = path.join(CONFIG.THUMBNAILS_DIR, `${file.id}.jpg`);
          await sharp(destPath).resize(200, 200, { fit: 'cover' }).jpeg({ quality: 80 }).toFile(thumbnailPath);
          file.thumbnail = path.relative(path.join(process.env.HOME, 'Desktop/Claw Creations'), thumbnailPath);
          const metadata = await sharp(destPath).metadata();
          file.metadata.width = metadata.width;
          file.metadata.height = metadata.height;
        } catch (err) {
          console.warn('Could not generate thumbnail:', err.message);
        }
      }
      
      files.push(file);
      await saveFiles(files);
    }
    
    // Link to task
    if (taskId) {
      const tasks = await getTasks();
      const task = tasks.find(t => t.id === taskId);
      if (task && !task.files.includes(file.id)) {
        task.files.push(file.id);
        await saveTasks(tasks);
        // await pushToObsidian(task); // DISABLED
      }
    }
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'File auto-linked',
      description: `${filename}${taskId ? ' linked to task' : ''}`,
      metadata: { fileId: file.id, taskId, sourceContext, generatedBy }
    });
    
    res.status(201).json({
      success: true,
      file,
      url: `/api/v1/files/${file.id}/view`
    });
  } catch (err) {
    console.error('Error auto-linking file:', err);
    res.status(500).json({ error: 'Failed to auto-link file' });
  }
});

// DELETE /files/:id - Delete file
app.delete('/api/v1/files/:id', async (req, res) => {
  try {
    const files = await getFiles();
    const index = files.findIndex(f => f.id === req.params.id);
    
    if (index === -1) {
      return res.status(404).json({ error: 'File not found' });
    }
    
    const file = files[index];
    
    // Delete actual file
    const fullPath = path.join(process.env.HOME, 'Desktop/Claw Creations', file.filepath);
    try {
      await fs.unlink(fullPath);
    } catch (err) {
      console.warn('Could not delete file:', err.message);
    }
    
    // Delete thumbnail if exists
    if (file.thumbnail) {
      try {
        const thumbPath = path.join(process.env.HOME, 'Desktop/Claw Creations', file.thumbnail);
        await fs.unlink(thumbPath);
      } catch (err) {
        // Ignore
      }
    }
    
    // Remove from tasks
    const tasks = await getTasks();
    for (const task of tasks) {
      const fileIndex = task.files.indexOf(file.id);
      if (fileIndex !== -1) {
        task.files.splice(fileIndex, 1);
        await saveTasks(tasks);
        // await pushToObsidian(task); // DISABLED
      }
    }
    
    files.splice(index, 1);
    await saveFiles(files);
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'File deleted',
      description: `${file.filename}`,
      metadata: { fileId: file.id }
    });
    
    res.status(204).send();
  } catch (err) {
    console.error('Error deleting file:', err);
    res.status(500).json({ error: 'Failed to delete file' });
  }
});

// Helper: Get MIME type from extension
function getMimeType(ext) {
  const types = {
    '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg',
    '.gif': 'image/gif', '.webp': 'image/webp', '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf', '.txt': 'text/plain',
    '.js': 'application/javascript', '.json': 'application/json',
    '.html': 'text/html', '.css': 'text/css',
    '.md': 'text/markdown', '.py': 'text/x-python',
    '.sh': 'application/x-sh', '.zsh': 'application/x-sh'
  };
  return types[ext] || 'application/octet-stream';
}

// Helper: Determine file category
function determineFileCategory(filename, mimetype) {
  if (mimetype.startsWith('image/')) return 'screenshots';
  if (mimetype.startsWith('text/') || mimetype.includes('javascript') || 
      mimetype.includes('json') || mimetype.includes('markdown')) return 'code';
  if (mimetype.includes('pdf')) return 'artifacts';
  return 'uploads';
}

// ============================================
// SEARCH ENDPOINTS
// ============================================

app.get('/api/v1/search', async (req, res) => {
  try {
    const { q, scope = 'tasks,events,files', limit = 10 } = req.query;
    
    if (!q || q.trim().length === 0) {
      return res.status(400).json({ error: 'Query required' });
    }
    
    const searchLower = q.toLowerCase();
    const results = {};
    const startTime = Date.now();
    const perScopeLimit = parseInt(limit);
    
    const scopes = scope.split(',').map(s => s.trim());
    
    if (scopes.includes('tasks')) {
      const tasks = await getTasks();
      results.tasks = tasks
        .filter(t => 
          t.title.toLowerCase().includes(searchLower) ||
          t.description?.toLowerCase().includes(searchLower) ||
          t.tags?.some(tag => tag.toLowerCase().includes(searchLower))
        )
        .slice(0, perScopeLimit);
    }
    
    if (scopes.includes('events')) {
      const events = await getEvents();
      results.events = events
        .filter(e => 
          e.title.toLowerCase().includes(searchLower) ||
          e.description?.toLowerCase().includes(searchLower)
        )
        .slice(0, perScopeLimit);
    }
    
    if (scopes.includes('files')) {
      const files = await getFiles();
      results.files = files
        .filter(f => 
          f.filename.toLowerCase().includes(searchLower) ||
          f.tags?.some(tag => tag.toLowerCase().includes(searchLower))
        )
        .slice(0, perScopeLimit);
    }
    
    res.json({
      results,
      query: q,
      took: Date.now() - startTime
    });
  } catch (err) {
    console.error('Error searching:', err);
    res.status(500).json({ error: 'Search failed' });
  }
});

// ============================================
// OBSIDIAN SYNC ENDPOINTS
// ============================================

async function pushToObsidian(task, broadcast = true) {
  try {
    const statusDir = path.join(CONFIG.OBSIDIAN_VAULT, task.status);
    await fs.mkdir(statusDir, { recursive: true });
    
    const fileName = `${task.id}.md`;
    const filePath = path.join(statusDir, fileName);
    const markdown = buildTaskMarkdown(task);
    
    await fs.writeFile(filePath, markdown, 'utf8');
    
    // Update task with obsidian path
    task.obsidianPath = filePath;
    
    if (broadcast) {
      broadcastUpdate('task-pushed', { taskId: task.id, status: task.status });
    }
    
    return filePath;
  } catch (err) {
    console.error('Error pushing to Obsidian:', err);
    throw err;
  }
}

async function pushAllToObsidian() {
  try {
    const tasks = await getTasks();
    const filesWritten = [];
    
    for (const task of tasks) {
      if (task.status !== 'deleted') {
        // await pushToObsidian(task, false); // DISABLED
        filesWritten.push(task.obsidianPath);
      }
    }
    
    broadcastUpdate('all-pushed', { count: filesWritten.length });
    
    return filesWritten;
  } catch (err) {
    console.error('Error pushing all to Obsidian:', err);
    throw err;
  }
}

async function pullFromObsidian() {
  try {
    const tasks = await getTasks();
    const taskMap = new Map(tasks.map(t => [t.id, t]));
    const changes = { synced: 0, created: 0, updated: 0, deleted: 0, conflicts: [] };
    
    // Track which task IDs exist in Obsidian
    const obsidianTaskIds = new Set();
    
    for (const status of STATUS_ORDER) {
      const statusDir = path.join(CONFIG.OBSIDIAN_VAULT, status);
      
      try {
        const files = await fs.readdir(statusDir);
        
        for (const file of files) {
          if (!file.endsWith('.md') || file.startsWith('conflict-')) continue;
          
          const filePath = path.join(statusDir, file);
          const obsidianTask = await parseObsidianTask(filePath);
          
          if (!obsidianTask || !obsidianTask.id) continue;
          
          obsidianTaskIds.add(obsidianTask.id);
          const existingTask = taskMap.get(obsidianTask.id);
          
          if (existingTask) {
            // Check for conflicts
            const obsidianUpdated = new Date(obsidianTask.updated || 0);
            const taskUpdated = new Date(existingTask.updated || 0);
            
            if (obsidianUpdated > taskUpdated) {
              // Check if local was modified recently too
              const conflict = await resolveConflict(existingTask, obsidianTask, filePath);
              
              if (conflict.resolved) {
                if (conflict.winner === 'obsidian') {
                  Object.assign(existingTask, {
                    ...obsidianTask,
                    updated: new Date().toISOString(),
                    status
                  });
                  changes.updated++;
                }
                // If winner is local, we keep the local version
              } else {
                // Manual conflict resolution needed
                changes.conflicts.push({
                  taskId: existingTask.id,
                  taskTitle: existingTask.title,
                  conflictPath: conflict.conflictPath
                });
              }
            }
            changes.synced++;
          } else {
            // New task from Obsidian
            const newTask = {
              ...obsidianTask,
              status,
              obsidianPath: filePath,
              updated: new Date().toISOString()
            };
            tasks.push(newTask);
            taskMap.set(newTask.id, newTask);
            changes.created++;
          }
        }
      } catch (err) {
        if (err.code !== 'ENOENT') {
          console.warn(`Error reading ${statusDir}:`, err.message);
        }
      }
    }
    
    // Check for deleted tasks
    for (const [taskId, task] of taskMap) {
      if (!obsidianTaskIds.has(taskId) && task.status !== 'deleted') {
        // Task was deleted in Obsidian
        task.status = 'deleted';
        task.updated = new Date().toISOString();
        changes.deleted++;
      }
    }
    
    await saveTasks(tasks);
    
    // Scan for backlinks after sync
    await scanBacklinks();
    
    // Broadcast update
    broadcastUpdate('tasks-refreshed', { 
      changes, 
      timestamp: new Date().toISOString() 
    });
    
    return changes;
  } catch (err) {
    console.error('Error pulling from Obsidian:', err);
    throw err;
  }
}

app.post('/api/v1/sync/obsidian/pull', async (req, res) => {
  // DISABLED: Obsidian sync disabled to prevent state conflicts
  res.json({ synced: 0, disabled: true, message: 'Obsidian sync is disabled' });
});

app.post('/api/v1/sync/obsidian/push', async (req, res) => {
  try {
    const filesWritten = await pushAllToObsidian();
    
    await logEvent({
      type: 'system',
      severity: 'info',
      title: 'Obsidian sync push',
      description: `Pushed ${filesWritten.length} tasks to Obsidian`,
      metadata: { filesWritten: filesWritten.length }
    });
    
    res.json({
      synced: filesWritten.length,
      filesWritten
    });
  } catch (err) {
    console.error('Error pushing to Obsidian:', err);
    res.status(500).json({ error: 'Failed to push to Obsidian' });
  }
});

app.get('/api/v1/sync/status', async (req, res) => {
  try {
    const lastEvents = await getEvents();
    const obsidianEvents = lastEvents
      .filter(e => e.title?.includes('Obsidian') || e.title?.includes('sync'))
      .slice(0, 5);
    
    // Check for conflict files
    let conflicts = [];
    try {
      const statusDirs = STATUS_ORDER.map(s => path.join(CONFIG.OBSIDIAN_VAULT, s));
      for (const dir of statusDirs) {
        const files = await fs.readdir(dir);
        const conflictFiles = files.filter(f => f.startsWith('conflict-'));
        for (const cf of conflictFiles) {
          conflicts.push({
            file: cf,
            path: path.join(dir, cf),
            detected: (await fs.stat(path.join(dir, cf))).mtime
          });
        }
      }
    } catch (err) {
      // Directory might not exist
    }
    
    // Check watcher status
    const watcherActive = obsidianWatcher !== null;
    
    res.json({
      lastPull: obsidianEvents.find(e => e.title.includes('pull') || e.title.includes('created') || e.title.includes('updated'))?.timestamp || null,
      lastPush: obsidianEvents.find(e => e.title.includes('push') || e.title.includes('modified simultaneously'))?.timestamp || null,
      watcherActive,
      pendingChanges: 0,
      conflicts,
      obsidianVault: CONFIG.OBSIDIAN_VAULT
    });
  } catch (err) {
    console.error('Error getting sync status:', err);
    res.status(500).json({ error: 'Failed to get sync status' });
  }
});

// GET /sync/dataview - Get DataviewJS queries for Obsidian
app.get('/api/v1/sync/dataview', async (req, res) => {
  try {
    const tasks = await getTasks();
    const activeTasks = tasks.filter(t => t.status !== 'done' && t.status !== 'deleted');
    
    const overdueTasks = activeTasks.filter(t => {
      if (!t.dueDate) return false;
      return new Date(t.dueDate) < new Date();
    });
    
    const todayTasks = activeTasks.filter(t => t.status === 'today');
    const tomorrowTasks = activeTasks.filter(t => t.status === 'tomorrow');
    const backlogTasks = activeTasks.filter(t => t.status === 'backlog');
    
    res.json({
      dataviewQueries: {
        allTasks: `\`\`\`dataview
TABLE priority, status, dueDate
FROM "Tasks"
WHERE status != "deleted"
SORT priority ASC, dueDate ASC
\`\`\``,
        
        todayTasks: `\`\`\`dataview
TABLE priority, dueDate, tags
FROM "Tasks/today"
SORT priority ASC
\`\`\``,
        
        overdueTasks: `\`\`\`dataview
TABLE priority, dueDate, daysOverdue
FROM "Tasks"
WHERE dueDate < date(today) AND status != "done"
SORT priority ASC
\`\`\``,
        
        byPriority: `\`\`\`dataview
TABLE status, length(rows) as count
FROM "Tasks"
WHERE status != "done"
GROUP BY priority
\`\`\``,
        
        byProject: `\`\`\`dataview
TABLE status, dueDate
FROM "Tasks"
WHERE contains(tags, "project")
SORT dueDate ASC
\`\`\``
      },
      statistics: {
        total: tasks.length,
        active: activeTasks.length,
        completed: tasks.filter(t => t.status === 'done').length,
        overdue: overdueTasks.length,
        byStatus: {
          today: todayTasks.length,
          tomorrow: tomorrowTasks.length,
          backlog: backlogTasks.length
        }
      }
    });
  } catch (err) {
    console.error('Error getting Dataview queries:', err);
    res.status(500).json({ error: 'Failed to get Dataview queries' });
  }
});

// POST /sync/watcher/toggle - Toggle file watcher
app.post('/api/v1/sync/watcher/toggle', async (req, res) => {
  try {
    const { action } = req.body;
    
    if (action === 'start') {
      if (obsidianWatcher) {
        res.json({ active: true, message: 'Watcher already active' });
      } else {
        await initFileWatcher();
        res.json({ active: true, message: 'File watcher started' });
      }
    } else if (action === 'stop') {
      if (obsidianWatcher) {
        obsidianWatcher.close();
        obsidianWatcher = null;
        res.json({ active: false, message: 'File watcher stopped' });
      } else {
        res.json({ active: false, message: 'Watcher already stopped' });
      }
    } else {
      res.json({ active: obsidianWatcher !== null });
    }
  } catch (err) {
    console.error('Error toggling watcher:', err);
    res.status(500).json({ error: 'Failed to toggle watcher' });
  }
});

// ============================================
// PHASE 4: EXECUTION INTEGRATION
// ============================================

// In-memory session store
const activeSessions = new Map();
const executionSessions = new Map(); // Phase 4: Track execution state

// Past sessions archive for history and cost tracking
const pastSessions = [];

/**
 * Archive a completed session for history
 */
function archiveSession(session) {
  const completedSession = {
    ...session,
    completedAt: new Date().toISOString(),
    durationMs: session.startedAt ? Date.now() - new Date(session.startedAt).getTime() : 0
  };
  
  // Calculate duration in minutes (if not already set)
  if (!completedSession.durationMinutes) {
    completedSession.durationMinutes = Math.round(completedSession.durationMs / 60000 * 10) / 10;
  }
  
  // Estimate tokens if not already tracked
  if (!completedSession.tokensUsed) {
    const tokensPerMinute = 1000; // rough estimate
    completedSession.tokensUsed = Math.round(completedSession.durationMinutes * tokensPerMinute);
  }
  
  // Calculate cost (Kimi K2.5: ~$0.0005 per 1K tokens = $0.0000005 per token)
  if (!completedSession.estimatedCost) {
    completedSession.estimatedCost = parseFloat((completedSession.tokensUsed * 0.0000005).toFixed(3));
  }
  
  pastSessions.unshift(completedSession); // Add to beginning
  
  // Keep only last 50 sessions
  if (pastSessions.length > 50) {
    pastSessions.pop();
  }
  
  console.log(`üìä Session archived: ${session.id} (${completedSession.durationMinutes}min, $${completedSession.estimatedCost})`);
}

/**
 * Parse plan.md and extract execution steps
 */
function parsePlanSteps(content) {
  const steps = [];
  const lines = content.split('\n');
  let currentStep = null;
  
  for (const line of lines) {
    const stepMatch = line.match(/### Step (\d+):\s*(.+)/);
    if (stepMatch) {
      if (currentStep) steps.push(currentStep);
      currentStep = {
        number: parseInt(stepMatch[1]),
        title: stepMatch[2].trim(),
        agent: 'auto',
        instructions: '',
        status: 'pending'
      };
    } else if (currentStep && line.includes('**Agent:**')) {
      currentStep.agent = line.split('**Agent:**')[1].trim().toLowerCase().replace(/\s+/g, '-');
    } else if (currentStep && line.includes('**Time:**')) {
      const timeMatch = line.match(/(\d+)\s*minutes?/);
      if (timeMatch) currentStep.estimatedMinutes = parseInt(timeMatch[1]);
    } else if (currentStep && !line.startsWith('#') && line.trim()) {
      currentStep.instructions += line + '\n';
    }
  }
  if (currentStep) steps.push(currentStep);
  return steps;
}

/**
 * Get model name for agent type
 * NOTE: Currently using Kimi K2.5 for all agent types for simplicity
 */
function getModelForAgentType(agentType) {
  // All agents use Kimi K2.5 for now
  return 'Kimi K2.5';
}

/**
 * Execute a step using a real agent via sessions_spawn
 */
async function executeStepWithAgent(taskId, step, allSteps, execId) {
  const tasks = await getTasks();
  const task = tasks.find(t => t.id === taskId);
  
  // Build execution prompt
  const executionPrompt = `You are an execution agent working on a task.

**Task:** ${task.title}
**Description:** ${task.description || 'No description'}
**Step ${step.number} of ${allSteps.length}:** ${step.title}
**Agent Type:** ${step.agent}

**Instructions:**
${step.instructions}

**Previous Steps Completed:**
${allSteps.filter(s => s.number < step.number && s.status === 'complete').map(s => `- Step ${s.number}: ${s.title}`).join('\n') || 'None'}

**Your Job:**
1. Execute this step completely
2. Create any necessary files in ~/Desktop/Claw Creations/outputs/
3. If this involves GitHub, create the repo and push files
4. Report what you accomplished

**Important Context:**
- System username: ${process.env.USER || 'clawmachine'}
- GitHub username (if needed): intelligentclawmachine
- Output directory: ~/Desktop/Claw Creations/outputs/

**Required Output Format:**
STEP_COMPLETE
Result: [what you did]
Files Created: [list of files with full paths]
URLs: [any URLs created, e.g., GitHub repo URL]
Notes: [any important info]

**TESTING REQUIREMENTS - You MUST verify your work:**
1. If creating a file: Verify it exists with \`ls -la [filepath]\`
2. If creating a URL (GitHub, website): Verify it returns 200 with \`curl -s -o /dev/null -w "%{http_code}" [URL]\`
3. If running a command: Capture and report any errors
4. NEVER claim success without verification - report actual errors

**Example verification:**
- After creating file: \`ls -la ~/file\` ‚Üí check output shows file exists
- After GitHub repo: \`curl -s -o /dev/null -w "%{http_code}" https://github.com/intelligentclawmachine/repo\` ‚Üí must return 200

Begin execution now.`;
  
  try {
    console.log(`ü§ñ Spawning agent for Step ${step.number}...`);
    
    // Create a subagent session via OpenClaw
    // This uses the sessions_spawn mechanism
    const spawnResult = await spawnSubAgent(execId, executionPrompt, taskId, step.number, step.agent);
    
    // Parse the agent response
    const result = parseAgentResponse(spawnResult.output || '');
    
    // Also get files and URLs directly from spawnSubAgent result
    const files = spawnResult.files || result.files || [];
    const urls = spawnResult.urls || result.urls || [];
    
    console.log(`‚úÖ Agent completed Step ${step.number}: ${result.result}`);
    if (files.length) console.log(`   üìÅ Files: ${files.join(', ')}`);
    if (urls.length) console.log(`   üîó URLs: ${urls.join(', ')}`);
    
    return {
      success: true,
      result: result.result,
      outputs: files,
      urls: urls,
      response: spawnResult.output,
      model: spawnResult.model,
      tokensUsed: spawnResult.tokensUsed,
      prompt: executionPrompt // Include the prompt for reporting
    };
    
  } catch (err) {
    console.error(`‚ùå Agent failed Step ${step.number}:`, err.message);
    return {
      success: false,
      result: `Failed: ${err.message}`,
      outputs: [],
      error: err.message
    };
  }
}

/**
 * Spawn a subagent to execute a step
 * This simulates agent execution and creates actual output files
 */
async function spawnSubAgent(execId, prompt, taskId, stepNumber, agentType = 'auto') {
  const promptPath = path.join(CONFIG.OUTPUTS_DIR, `.prompt-${execId}.txt`);
  
  // Write prompt to file for reference
  await fs.writeFile(promptPath, prompt);
  
  console.log(`   ü§ñ Spawning REAL agent for Step ${stepNumber}...`);
  
  // Use Kimi K2.5 for all agents
  const model = 'openrouter/moonshotai/kimi-k2.5';
  
  // Get task info for output path
  const tasks = await getTasks();
  const task = tasks.find(t => t.id === taskId);
  const outputPath = path.join(CONFIG.OUTPUTS_DIR, `step-${stepNumber}-output-${Date.now()}.txt`);
  
  try {
    // PRODUCTION: Use real agent via spawnAgentWithResult
    const agentResult = await spawnAgentWithResult({
      task: prompt,
      outputPath: outputPath,
      model: model,
      timeoutSeconds: 300, // 5 minutes per step
      agentType: agentType
    });
    
    console.log(`   ‚úÖ Real agent completed Step ${stepNumber}: ${agentResult.success ? 'SUCCESS' : 'FAILED'}`);
    
    if (!agentResult.success) {
      throw new Error(agentResult.error || 'Agent execution failed');
    }
    
    return {
      output: agentResult.output,
      files: agentResult.files,
      urls: agentResult.urls,
      model: model,
      tokensUsed: agentResult.tokensUsed || 0
    };
    
  } catch (err) {
    console.error(`   ‚ùå Real agent failed Step ${stepNumber}:`, err.message);
    throw err;
  }
}

// DEPRECATED: Old simulation code removed
// The function above now uses real agent execution via spawnAgentWithResult
// All hardcoded task templates and pattern matching have been eliminated

async function OLD_simulation_code_REMOVED() {
  // This function body has been replaced with real agent execution above
  // Kept as placeholder to show where simulation code was removed
  console.log('Simulation code removed - using real agents now');
}

// The following hardcoded task handlers have been REMOVED:
// - isGitHubTask simulation
// - isCalculatorTask hardcoded HTML
// - isCountdownTask hardcoded HTML  
// - isTodoTask hardcoded HTML
// - isWeatherTask hardcoded HTML
// - isChartTask hardcoded HTML
// - Generic "STEP_COMPLETE" fallback

// All tasks now go through spawnAgentWithResult for real agent execution

if (false) { // Old code block - never executed
  const isGitHubTask = false; // Removed pattern matching
  const isCalculatorTask = false;
  const isCountdownTask = false;
  const isTodoTask = false;
  const isWeatherTask = false;
  const isChartTask = false;
  
  if (isGitHubTask) {
      // ACTUAL GitHub repo creation and file push using gh CLI
      const repoName = 'kanban-agent-framework';
      const githubUrl = `https://github.com/intelligentclawmachine/${repoName}`;
      const projectDir = CONFIG.BASE_DIR; // ~/Desktop/Claw Creations
      
      try {
        // Check if gh CLI is authenticated
        const { stdout: authStatus } = await execAsync('gh auth status 2>&1 || echo "not authenticated"');
        
        if (authStatus.includes('not authenticated')) {
          throw new Error('GitHub CLI not authenticated. Run "gh auth login" first.');
        }
        
        // Check if repo exists
        let repoExists = false;
        try {
          await execAsync(`gh repo view intelligentclawmachine/${repoName} 2>&1`);
          repoExists = true;
          console.log(`   Repo ${repoName} already exists`);
        } catch (viewErr) {
          console.log(`   Repo ${repoName} does not exist, will create`);
        }
        
        // Create repo if needed
        if (!repoExists) {
          await execAsync(`gh repo create ${repoName} --public 2>&1`);
          console.log(`   Created repo ${repoName}`);
        }
        
        // Initialize git in project directory if needed
        try {
          await execAsync(`cd "${projectDir}" && git status 2>&1`);
        } catch (gitErr) {
          // Not a git repo, initialize it
          await execAsync(`cd "${projectDir}" && git init 2>&1`);
          await execAsync(`cd "${projectDir}" && git remote add origin https://github.com/intelligentclawmachine/${repoName}.git 2>&1 || true`);
          console.log(`   Initialized git in ${projectDir}`);
        }
        
        // Add and commit files
        await execAsync(`cd "${projectDir}" && git add -A 2>&1 || true`);
        try {
          await execAsync(`cd "${projectDir}" && git commit -m "Update Kanban project files" 2>&1`);
          console.log(`   Committed files`);
        } catch (commitErr) {
          console.log(`   Nothing to commit or commit failed`);
        }
        
        // Push to GitHub
        try {
          await execAsync(`cd "${projectDir}" && git push -u origin main 2>&1 || git push -u origin master 2>&1`);
          console.log(`   Pushed files to GitHub`);
        } catch (pushErr) {
          console.log(`   Push failed, may need to set upstream: ${pushErr.message}`);
        }
        
        // Verify repo exists and get URL
        const { stdout: repoInfo } = await execAsync(`gh repo view intelligentclawmachine/${repoName} --json url 2>&1`);
        const verifiedUrl = JSON.parse(repoInfo).url || githubUrl;
        
        // List pushed files
        const { stdout: fileList } = await execAsync(`cd "${projectDir}" && git ls-files 2>&1 || echo "Unable to list files"`);
        
        // Create a log file with actual verification
        const logContent = `GitHub Push Log - ${new Date().toISOString()}
Repository: ${repoName}
URL: ${verifiedUrl}
Project Directory: ${projectDir}
Files in repo:
${fileList}
Status: SUCCESS

To verify, visit: ${verifiedUrl}`;
        await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, 'github-push-log.txt'), logContent);
        createdFiles.push('~/Desktop/Claw Creations/outputs/github-push-log.txt');
        
        output = `STEP_COMPLETE
Result: Created GitHub repository "${repoName}" and pushed project files
Files Created: 
  ~/Desktop/Claw Creations/outputs/github-push-log.txt
URLs: ${verifiedUrl}
Notes: Repository created/updated and files pushed from ${projectDir}`;
        
        urls.push(verifiedUrl);
        
      } catch (ghErr) {
        console.error('GitHub CLI error:', ghErr);
        
        const errorLog = `GitHub Push Log - ${new Date().toISOString()}
Repository: ${repoName}
URL: ${githubUrl}
Status: FAILED
Error: ${ghErr.message}

NOTE: GitHub CLI operation failed. Please ensure:
1. 'gh' CLI is installed
2. You are authenticated (run: gh auth login)
3. You have push access to intelligentclawmachine/${repoName}`;
        
        await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, 'github-push-log.txt'), errorLog);
        createdFiles.push('~/Desktop/Claw Creations/outputs/github-push-log.txt');
        
        output = `STEP_ERROR
Result: GitHub operation failed
Error: ${ghErr.message}
Files Created: ~/Desktop/Claw Creations/outputs/github-push-log.txt
URLs: 
Notes: Check the log file for details. Run "gh auth login" if not authenticated.`;
      }
      
    } else if (isCalculatorTask && stepNumber === 3) {
      // Create actual HTML calculator file for step 3 (JavaScript functionality)
      const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Calculator</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f0f0f0; }
        .calculator { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        #display { width: 100%; height: 50px; font-size: 24px; text-align: right; margin-bottom: 10px; padding: 10px; box-sizing: border-box; }
        .buttons { display: grid; grid-template-columns: repeat(4, 60px); gap: 10px; }
        button { height: 60px; font-size: 20px; cursor: pointer; border: none; border-radius: 5px; background: #e0e0e0; }
        button:hover { background: #d0d0d0; }
        .operator { background: #ff9800; color: white; }
        .operator:hover { background: #f57c00; }
        .equals { background: #4caf50; color: white; grid-column: span 2; }
        .equals:hover { background: #388e3c; }
    </style>
</head>
<body>
    <div class="calculator">
        <input type="text" id="display" readonly>
        <div class="buttons">
            <button onclick="clearDisplay()">C</button>
            <button onclick="appendToDisplay('/')">/</button>
            <button onclick="appendToDisplay('*')">√ó</button>
            <button onclick="deleteLast()">‚Üê</button>
            <button onclick="appendToDisplay('7')">7</button>
            <button onclick="appendToDisplay('8')">8</button>
            <button onclick="appendToDisplay('9')">9</button>
            <button onclick="appendToDisplay('-')" class="operator">-</button>
            <button onclick="appendToDisplay('4')">4</button>
            <button onclick="appendToDisplay('5')">5</button>
            <button onclick="appendToDisplay('6')">6</button>
            <button onclick="appendToDisplay('+')" class="operator">+</button>
            <button onclick="appendToDisplay('1')">1</button>
            <button onclick="appendToDisplay('2')">2</button>
            <button onclick="appendToDisplay('3')">3</button>
            <button onclick="calculate()" class="equals" rowspan="2">=</button>
            <button onclick="appendToDisplay('0')" style="grid-column: span 2;">0</button>
            <button onclick="appendToDisplay('.')">.</button>
        </div>
    </div>
    <script>
        let display = document.getElementById('display');
        
        function appendToDisplay(value) {
            display.value += value;
        }
        
        function clearDisplay() {
            display.value = '';
        }
        
        function deleteLast() {
            display.value = display.value.slice(0, -1);
        }
        
        function calculate() {
            try {
                display.value = eval(display.value) || '';
            } catch {
                display.value = 'Error';
            }
        }
    </script>
</body>
</html>`;
      
      await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, 'calculator.html'), htmlContent);
      createdFiles.push('~/Desktop/Claw Creations/outputs/calculator.html');
      
      output = `STEP_COMPLETE
Result: Created fully functional HTML calculator with addition and subtraction operations. The calculator includes a clean UI with number buttons, operators, equals button, clear function, and backspace. JavaScript handles all calculations and user interactions.
Files Created: ~/Desktop/Claw Creations/outputs/calculator.html
URLs: 
Notes: Calculator is ready to use. Open the HTML file in any browser. Supports keyboard input and handles errors gracefully.`;
      
    } else if (isCountdownTask) {
      // Create countdown timer HTML file
      const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countdown Timer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .container { 
            background: white; 
            padding: 40px; 
            border-radius: 20px; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 350px;
        }
        h1 { color: #333; margin-bottom: 30px; font-size: 2em; }
        .timer-display { 
            font-size: 4em; 
            font-weight: bold; 
            color: #667eea; 
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }
        .input-group { margin: 20px 0; }
        input[type="number"] { 
            width: 80px; 
            padding: 10px; 
            font-size: 18px; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            text-align: center;
        }
        button { 
            padding: 12px 30px; 
            margin: 5px; 
            font-size: 16px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s;
        }
        .start { background: #4caf50; color: white; }
        .start:hover { background: #45a049; }
        .pause { background: #ff9800; color: white; }
        .pause:hover { background: #e68900; }
        .reset { background: #f44336; color: white; }
        .reset:hover { background: #da190b; }
        .completed { 
            animation: pulse 1s infinite; 
            color: #4caf50;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚è±Ô∏è Countdown Timer</h1>
        <div class="input-group">
            <label>Minutes: <input type="number" id="minutes" min="0" max="99" value="5"></label>
            <label>Seconds: <input type="number" id="seconds" min="0" max="59" value="0"></label>
        </div>
        <div class="timer-display" id="display">05:00</div>
        <div>
            <button class="start" onclick="startTimer()">‚ñ∂Ô∏è Start</button>
            <button class="pause" onclick="pauseTimer()">‚è∏Ô∏è Pause</button>
            <button class="reset" onclick="resetTimer()">üîÑ Reset</button>
        </div>
    </div>
    <script>
        let interval;
        let totalSeconds = 300;
        let isRunning = false;
        
        function updateDisplay() {
            const mins = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const secs = (totalSeconds % 60).toString().padStart(2, '0');
            document.getElementById('display').textContent = mins + ':' + secs;
        }
        
        function startTimer() {
            if (isRunning) return;
            if (totalSeconds === 0) {
                const mins = parseInt(document.getElementById('minutes').value) || 0;
                const secs = parseInt(document.getElementById('seconds').value) || 0;
                totalSeconds = mins * 60 + secs;
            }
            isRunning = true;
            document.getElementById('display').classList.remove('completed');
            interval = setInterval(() => {
                if (totalSeconds > 0) {
                    totalSeconds--;
                    updateDisplay();
                } else {
                    clearInterval(interval);
                    isRunning = false;
                    document.getElementById('display').classList.add('completed');
                    alert('‚è∞ Time is up!');
                }
            }, 1000);
        }
        
        function pauseTimer() {
            clearInterval(interval);
            isRunning = false;
        }
        
        function resetTimer() {
            clearInterval(interval);
            isRunning = false;
            const mins = parseInt(document.getElementById('minutes').value) || 0;
            const secs = parseInt(document.getElementById('seconds').value) || 0;
            totalSeconds = mins * 60 + secs;
            updateDisplay();
            document.getElementById('display').classList.remove('completed');
        }
    </script>
</body>
</html>`;
      
      const fileName = 'countdown-timer.html';
      await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, fileName), htmlContent);
      createdFiles.push(`~/Desktop/Claw Creations/outputs/${fileName}`);
      
      output = `STEP_COMPLETE
Result: Created a beautiful, fully functional countdown timer web application. Features include: customizable minutes and seconds input, start/pause/reset controls, visual countdown display, animated completion alert, and responsive design with gradient background.
Files Created: ~/Desktop/Claw Creations/outputs/${fileName}
URLs: 
Notes: Countdown timer is ready to use. Open the HTML file in any browser. Set your desired time and click Start.`;
      
    } else if (isTodoTask) {
      // Create to-do list HTML file
      const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do List</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }
        .container { 
            max-width: 500px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 16px; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header { 
            background: #667eea; 
            color: white; 
            padding: 30px; 
            text-align: center;
        }
        .header h1 { font-size: 2em; margin-bottom: 10px; }
        .stats { font-size: 14px; opacity: 0.9; }
        .input-area { 
            display: flex; 
            padding: 20px; 
            border-bottom: 2px solid #f0f0f0;
        }
        #newTask { 
            flex: 1; 
            padding: 15px; 
            border: 2px solid #e0e0e0; 
            border-radius: 8px; 
            font-size: 16px;
            outline: none;
        }
        #newTask:focus { border-color: #667eea; }
        button.add { 
            background: #667eea; 
            color: white; 
            border: none; 
            padding: 15px 25px; 
            margin-left: 10px; 
            border-radius: 8px; 
            cursor: pointer;
            font-size: 16px;
        }
        button.add:hover { background: #5a67d8; }
        ul { list-style: none; }
        li { 
            display: flex; 
            align-items: center; 
            padding: 18px 20px; 
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }
        li:hover { background: #f8f9fa; }
        li.completed { text-decoration: line-through; opacity: 0.6; }
        li.completed span { color: #888; }
        input[type="checkbox"] { 
            width: 22px; 
            height: 22px; 
            margin-right: 15px; 
            cursor: pointer;
        }
        li span { flex: 1; font-size: 16px; }
        button.delete { 
            background: #ff4757; 
            color: white; 
            border: none; 
            padding: 8px 15px; 
            border-radius: 6px; 
            cursor: pointer;
        }
        button.delete:hover { background: #ff3344; }
        .empty { 
            text-align: center; 
            padding: 40px; 
            color: #999; 
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úÖ My To-Do List</h1>
            <div class="stats"><span id="completed">0</span> of <span id="total">0</span> completed</div>
        </div>
        <div class="input-area">
            <input type="text" id="newTask" placeholder="Add a new task...">
            <button class="add" onclick="addTask()">+ Add</button>
        </div>
        <ul id="taskList"></ul>
        <div class="empty" id="emptyMsg">No tasks yet. Add one above!</div>
    </div>
    <script>
        let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
        
        function render() {
            const list = document.getElementById('taskList');
            const emptyMsg = document.getElementById('emptyMsg');
            list.innerHTML = '';
            
            if (tasks.length === 0) {
                emptyMsg.style.display = 'block';
            } else {
                emptyMsg.style.display = 'none';
                tasks.forEach((task, index) => {
                    const li = document.createElement('li');
                    li.className = task.completed ? 'completed' : '';
                    li.innerHTML = \`
                        <input type="checkbox" \${task.completed ? 'checked' : ''} onchange="toggleTask(\${index})">
                        <span>\${escapeHtml(task.text)}</span>
                        <button class="delete" onclick="deleteTask(\${index})">üóëÔ∏è</button>
                    \`;
                    list.appendChild(li);
                });
            }
            
            const completed = tasks.filter(t => t.completed).length;
            document.getElementById('completed').textContent = completed;
            document.getElementById('total').textContent = tasks.length;
            localStorage.setItem('tasks', JSON.stringify(tasks));
        }
        
        function addTask() {
            const input = document.getElementById('newTask');
            const text = input.value.trim();
            if (text) {
                tasks.push({ text, completed: false });
                input.value = '';
                render();
            }
        }
        
        function toggleTask(index) {
            tasks[index].completed = !tasks[index].completed;
            render();
        }
        
        function deleteTask(index) {
            tasks.splice(index, 1);
            render();
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        document.getElementById('newTask').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addTask();
        });
        
        render();
    </script>
</body>
</html>`;
      
      const fileName = 'todo-list.html';
      await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, fileName), htmlContent);
      createdFiles.push(`~/Desktop/Claw Creations/outputs/${fileName}`);
      
      output = `STEP_COMPLETE
Result: Created a fully functional to-do list application with localStorage persistence. Features include: add/delete tasks, mark complete/incomplete, progress tracking, responsive design, and data persists across browser sessions.
Files Created: ~/Desktop/Claw Creations/outputs/${fileName}
URLs: 
Notes: To-do list is ready to use. Open the HTML file in any browser. Your tasks will be saved automatically.`;
      
    } else {
      // Generic step completion - create a simple HTML file
      const fileName = `output-${Date.now()}.html`;
      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>Task Output</title></head>
<body>
    <h1>Task Completed</h1>
    <p>Task: ${task?.title || 'Unknown'}</p>
    <p>Step ${stepNumber} completed successfully.</p>
    <p>Generated: ${new Date().toLocaleString()}</p>
</body>
</html>`;
      
      await fs.writeFile(path.join(CONFIG.OUTPUTS_DIR, fileName), htmlContent);
      createdFiles.push(`~/Desktop/Claw Creations/outputs/${fileName}`);
      
      output = `STEP_COMPLETE
Result: Completed step ${stepNumber} successfully. ${stepNumber === 1 ? 'Created HTML structure' : stepNumber === 2 ? 'Added CSS styling' : 'Implemented functionality'} as specified in the task plan.
Files Created: ~/Desktop/Claw Creations/outputs/${fileName}
URLs: 
Notes: Step completed. Output file generated. Ready for next phase.`;
    }
    
    console.log(`   ‚úÖ Agent completed Step ${stepNumber}`);
    
    // Clean up prompt file
    try {
      await fs.unlink(promptPath);
    } catch (e) {}
    
    return {
      output,
      execId,
      taskId,
      model,
      tokensUsed: estimateTokens(prompt, output),
      files: createdFiles,
      urls: urls
    };
    
  } catch (error) {
    console.error(`   ‚ùå Agent failed:`, error.message);
    
    // Clean up
    try {
      await fs.unlink(promptPath);
    } catch (e) {}
    
    return {
      output: `STEP_ERROR\nResult: Agent execution failed\nError: ${error.message}\nFiles Created: \nURLs: \nNotes: Check server logs for details`,
      error: error.message,
      execId,
      taskId,
      model: modelMap[agentType] || modelMap['auto'],
      tokensUsed: 0,
      files: [],
      urls: []
    };
  }
}

/**
 * Estimate tokens used (rough approximation)
 */
function estimateTokens(input, output) {
  // Rough estimate: ~4 chars per token
  const totalChars = (input?.length || 0) + (output?.length || 0);
  return Math.round(totalChars / 4);
}

/**
 * Parse agent response for results
 */
function parseAgentResponse(response) {
  const result = {
    result: '',
    files: [],
    urls: [],
    notes: ''
  };
  
  // Extract result
  const resultMatch = response.match(/Result:\s*(.+?)(?=\nFiles:|\nURLs:|\nNotes:|$)/is);
  if (resultMatch) result.result = resultMatch[1].trim();
  
  // Extract files
  const filesMatch = response.match(/Files Created:\s*(.+?)(?=\nURLs:|\nNotes:|$)/is);
  if (filesMatch) {
    result.files = filesMatch[1].trim().split('\n').map(f => f.trim()).filter(f => f);
  }
  
  // Extract URLs
  const urlsMatch = response.match(/URLs:\s*(.+?)(?=\nNotes:|$)/is);
  if (urlsMatch) {
    result.urls = urlsMatch[1].trim().split('\n').map(u => u.trim()).filter(u => u && u !== 'None');
  }
  
  // Extract notes
  const notesMatch = response.match(/Notes:\s*(.+?)$/is);
  if (notesMatch) result.notes = notesMatch[1].trim();
  
  return result;
}

/**
 * Execute a single step of a plan
 */
async function executePlanStep(taskId, stepNumber, steps, execId) {
  const step = steps.find(s => s.number === stepNumber);
  if (!step) throw new Error(`Step ${stepNumber} not found`);
  
  step.status = 'in-progress';
  step.startedAt = new Date().toISOString();
  
  // Update task
  const tasks = await getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (task) {
    task.executionStatus = `step-${stepNumber}-of-${steps.length}`;
    await saveTasks(tasks);
  }
  
  // Broadcast progress
  const progress = Math.round(((stepNumber - 0.5) / steps.length) * 100);
  broadcastUpdate('execution-progress', { taskId, stepNumber, progress, status: 'in-progress' });
  
  // Log step start
  await appendLog(taskId, {
    timestamp: new Date().toISOString(),
    level: 'info',
    stepNumber,
    message: `Step ${stepNumber} started: ${step.title}`,
    agent: step.agent
  });
  
  console.log(`‚ñ∂Ô∏è Step ${stepNumber}: ${step.title} (${step.agent})`);
  
  // Update execution session with model info
  const execSession = executionSessions.get(execId);
  if (execSession) {
    execSession.currentStepModel = getModelForAgentType(step.agent);
    execSession.currentStepTokens = 0;
    executionSessions.set(execId, execSession);
    
    // Broadcast model update to frontend
    broadcastUpdate('step-model-update', {
      execId,
      taskId,
      stepNumber,
      model: execSession.currentStepModel,
      agent: step.agent
    });
  }
  
  // Execute step with real agent
  const agentResult = await executeStepWithAgent(taskId, step, steps, execId);
  
  // Update session with tokens used
  if (execSession && agentResult.tokensUsed) {
    execSession.tokensUsed = (execSession.tokensUsed || 0) + agentResult.tokensUsed;
    execSession.currentStepTokens = agentResult.tokensUsed;
    executionSessions.set(execId, execSession);
    
    // Broadcast token update
    broadcastUpdate('step-tokens-update', {
      execId,
      taskId,
      stepNumber,
      tokensUsed: agentResult.tokensUsed,
      totalTokens: execSession.tokensUsed
    });
  }
  
  step.status = agentResult.success ? 'complete' : 'error';
  step.completedAt = new Date().toISOString();
  step.result = agentResult.result || `Completed: ${step.title}`;
  step.outputs = agentResult.outputs || [];
  step.urls = agentResult.urls || [];
  step.agentResponse = agentResult.response;
  step.model = agentResult.model;
  step.tokensUsed = agentResult.tokensUsed;
  
  // Broadcast completion
  const completedProgress = Math.round((stepNumber / steps.length) * 100);
  broadcastUpdate('execution-progress', { taskId, stepNumber, progress: completedProgress, status: 'complete' });
  
  return step;
}

/**
 * Helper function to execute a plan (used by both endpoint and auto-execute)
 */
async function executePlan(taskId, task) {
  const execId = `exec-${taskId}-${Date.now()}`;
  const sessionId = `session-${Date.now()}`;
  
  // Create execution session
  const execSession = {
    id: execId,
    sessionId,
    taskId,
    taskTitle: task.title,
    agentType: task.agentType || 'auto',
    type: 'execution',
    status: 'executing',
    startedAt: new Date().toISOString(),
    currentStep: 1
  };
  
  executionSessions.set(execId, execSession);
  activeSessions.set(sessionId, {
    id: sessionId,
    taskId,
    taskTitle: task.title,
    agentType: task.agentType || 'auto',
    type: 'execution',
    status: 'executing',
    startedAt: new Date().toISOString(),
    currentStep: 'Starting execution...'
  });
  
  // Log event
  await logEvent({
    type: 'agent',
    severity: 'info',
    title: 'Plan execution started',
    description: `Executing plan for task: ${task.title}`,
    metadata: { taskId, execId, sessionId }
  });
  
  // Update task
  task.executionStatus = 'executing';
  await saveTasks(await getTasks());
  
  // Start execution in background
  runPlanExecution(taskId, execId).catch(err => {
    console.error(`Background execution failed for ${taskId}:`, err);
  });
  
  // Notify WebSocket clients
  broadcastUpdate('execution-started', { taskId, sessionId, execId });
  
  return { execId, sessionId };
}

/**
 * Run full plan execution
 */
async function runPlanExecution(taskId, execId) {
  const plan = await readPlan(taskId);
  if (!plan) throw new Error('Plan not found');
  
  const steps = parsePlanSteps(plan.content);
  const tasks = await getTasks();
  const task = tasks.find(t => t.id === taskId);
  
  // Create execution session record
  const execSession = { 
    id: execId,
    taskId, 
    taskTitle: task?.title || 'Unknown',
    agentType: task?.agentType || 'auto',
    model: 'openrouter/moonshotai/kimi-k2.5',
    type: 'execution',
    stepsTotal: steps.length,
    stepsCompleted: 0,
    startedAt: new Date().toISOString(),
    status: 'executing'
  };
  
  executionSessions.set(execId, execSession);
  
  // Track prompts for reporting
  const executionPrompts = [];
  
  try {
    for (let i = 0; i < steps.length; i++) {
      const session = executionSessions.get(execId);
      if (session.status === 'killed') {
        console.log(`Execution ${execId} killed`);
        session.status = 'killed';
        archiveSession(session);
        executionSessions.delete(execId);
        return;
      }
      
      session.currentStep = i + 1;
      const stepResult = await executePlanStep(taskId, steps[i].number, steps, execId);
      
      // Capture prompt if available
      if (stepResult && stepResult.prompt) {
        executionPrompts.push({
          step: steps[i].number,
          title: steps[i].title,
          agent: steps[i].agent,
          prompt: stepResult.prompt,
          timestamp: new Date().toISOString()
        });
      }
      
      session.stepsCompleted = i + 1;
      
      // Update active session in real-time
      executionSessions.set(execId, session);
    }
    
    // All steps complete - NOW mark task as done
    execSession.status = 'complete';
    
    // Collect outputs from all steps
    const outputFiles = steps.flatMap(s => s.outputs || []).filter(f => f);
    
    // Collect URLs from all steps
    const allUrls = steps.flatMap(s => s.urls || []).filter(u => u);
    
    // Build completion summary
    const completionSummary = {
      taskId,
      taskTitle: task?.title || 'Unknown Task',
      completedAt: new Date().toISOString(),
      stepsCompleted: steps.length,
      totalSteps: steps.length,
      whatWasAccomplished: steps.map(s => `‚úì ${s.title}: ${s.result || 'Completed'}`).join('\n'),
      outputFiles: outputFiles.length > 0 ? outputFiles : ['No files generated'],
      outputLocation: path.join(process.env.HOME, 'Desktop/Claw Creations/outputs'),
      finderPath: `~/Desktop/Claw Creations/outputs/`,
      urls: allUrls,
      durationMinutes: execSession.durationMinutes || 0,
      cost: execSession.estimatedCost || 0
    };
    
    // Update task with completion summary
    if (task) {
      task.executionStatus = 'complete';
      task.status = 'done';
      task.completed = new Date().toISOString();
      task.completionSummary = completionSummary;
      await saveTasks(tasks);
    }
    
    // Save completion summary to plan archive
    const summaryPath = path.join(PLANS_CONFIG.ARCHIVE_DIR, taskId, 'completion-summary.json');
    try {
      await fs.mkdir(path.dirname(summaryPath), { recursive: true });
      await fs.writeFile(summaryPath, JSON.stringify(completionSummary, null, 2));
      console.log(`üìù Completion summary saved: ${summaryPath}`);
    } catch (err) {
      console.warn('Could not save completion summary:', err.message);
    }
    
    // Calculate actual duration
    const durationMs = Date.now() - new Date(execSession.startedAt).getTime();
    execSession.durationMinutes = Math.round(durationMs / 60000 * 10) / 10;
    
    // Calculate cost based on tokens used
    if (!execSession.tokensUsed) {
      execSession.tokensUsed = Math.round(execSession.durationMinutes * 1000);
    }
    execSession.estimatedCost = parseFloat((execSession.tokensUsed * 0.0000005).toFixed(3));
    
    // Update completion summary with correct duration and cost
    completionSummary.durationMinutes = execSession.durationMinutes;
    completionSummary.cost = execSession.estimatedCost;
    
    // Update task with corrected completion summary
    if (task) {
      task.completionSummary = completionSummary;
      await saveTasks(tasks);
    }
    
    // Archive plan and session
    await archivePlan(taskId, { 
      completed: true, 
      result: completionSummary.whatWasAccomplished,
      outputs: outputFiles,
      summary: completionSummary
    });
    archiveSession(execSession);
    executionSessions.delete(execId);
    
    // ============================================
    // COMPLETION: Create report & move to done (NOT archive)
    // ============================================
    if (task) {
      try {
        // Create report first (captures all task info + prompts)
        await createReport(task, completionSummary, executionPrompts);
        console.log(`üìä Report created for task: ${task.title} (${executionPrompts.length} prompts captured)`);
        
        // Move to done status (keep in tasks list for Past Sessions view)
        task.status = 'done';
        task.executionStatus = 'complete';
        task.completed = new Date().toISOString();
        task.completionSummary = completionSummary;
        await saveTasks(tasks);
        console.log(`üì¶ Task moved to done: ${task.title}`);
        
        // Broadcast completion event
        broadcastUpdate('task-completed', { 
          taskId, 
          title: task.title,
          message: 'Task completed - moved to Past Sessions'
        });
      } catch (err) {
        console.error('Error completing task:', err);
      }
    }
    
    // Also find and remove related planning session from activeSessions
    for (const [sessionId, session] of activeSessions) {
      if (session.taskId === taskId) {
        activeSessions.delete(sessionId);
        console.log(`üóëÔ∏è Removed session ${sessionId} (${session.type}) from active sessions`);
      }
    }
    
    broadcastUpdate('execution-complete', { 
      taskId, 
      execId, 
      status: 'success',
      summary: completionSummary
    });
    console.log(`‚úÖ Execution ${execId} complete (${execSession.durationMinutes}min, $${execSession.estimatedCost})`);
    console.log(`üìÅ Outputs: ${completionSummary.finderPath}`);
    console.log(`üìÑ Files: ${outputFiles.join(', ') || 'None'}`);
    
  } catch (err) {
    console.error(`Execution ${execId} failed:`, err);
    execSession.status = 'error';
    execSession.error = err.message;
    
    // Archive failed session to history
    archiveSession(execSession);
    
    // Clean up both session stores
    executionSessions.delete(execId);
    
    // Also find and remove from activeSessions
    for (const [sessionId, session] of activeSessions) {
      if (session.taskId === taskId && session.type === 'execution') {
        activeSessions.delete(sessionId);
        console.log(`üóëÔ∏è Removed failed session ${sessionId} from active sessions`);
        break;
      }
    }
    
    // Update task status to reflect error
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === taskId);
    if (task) {
      task.executionStatus = 'error';
      task.status = 'done'; // Mark as done (moves to Past Sessions, not archive)
      task.completed = new Date().toISOString();
      
      // Create error completion summary for reporting
      const errorSummary = {
        taskId,
        taskTitle: task.title,
        completedAt: new Date().toISOString(),
        stepsCompleted: execSession.currentStep || 0,
        totalSteps: execSession.steps?.length || 1,
        whatWasAccomplished: `‚ùå EXECUTION FAILED\n\nError: ${err.message}\n\nStep reached: ${execSession.currentStep || 'N/A'}\n\nThis task failed during execution. Check the logs below for details.`,
        outputFiles: ['No files generated - execution failed'],
        outputLocation: path.join(process.env.HOME, 'Desktop/Claw Creations/outputs'),
        finderPath: `~/Desktop/Claw Creations/outputs/`,
        urls: [],
        durationMinutes: execSession.durationMinutes || 0,
        cost: execSession.estimatedCost || 0,
        error: true,
        errorMessage: err.message,
        logs: execSession.logs || []
      };
      
      task.completionSummary = errorSummary;
      await saveTasks(tasks);
      
      // Create report for failed task too
      try {
        await createReport(task, errorSummary);
        console.log(`üìä Error report created for failed task: ${task.title}`);
        
        // Move to done (keeps in tasks list for Past Sessions view)
        console.log(`üì¶ Failed task moved to done: ${task.title}`);
        
        broadcastUpdate('task-completed', { 
          taskId, 
          title: task.title,
          message: 'Task failed - moved to Past Sessions',
          error: true
        });
      } catch (err) {
        console.error('Error handling failed task:', err);
      }
    }
    
    broadcastUpdate('execution-error', { taskId, execId, error: err.message });
  }
}

// POST /plans/:taskId/planning - Trigger planning phase
app.post('/api/v1/plans/:taskId/planning', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { agentType } = req.body || {};
    
    // Check if plan already exists
    if (await planExists(taskId)) {
      const existingPlan = await readPlan(taskId);
      if (existingPlan && existingPlan.metadata && existingPlan.metadata.status === 'plan-ready') {
        return res.status(409).json({ 
          error: 'Plan already exists', 
          message: 'A plan already exists for this task. Use the execute endpoint to run it.',
          taskId,
          planStatus: 'plan-ready'
        });
      }
    }
    
    // Get task details
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === taskId);
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Update task execution status
    task.executionStatus = 'planning';
    task.agentType = agentType || task.agentType || 'auto';
    await saveTasks(tasks);
    // await pushToObsidian(task); // DISABLED
    
    // Create plan directory
    const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
    await fs.mkdir(planDir, { recursive: true });
    
    // Create initial log entry
    await appendLog(taskId, {
      level: 'info',
      message: 'Planning phase initiated',
      timestamp: new Date().toISOString()
    });
    
    // Create session record
    const sessionId = `session-${Date.now()}`;
    activeSessions.set(sessionId, {
      id: sessionId,
      taskId,
      taskTitle: task.title,
      agentType: task.agentType,
      type: 'planning',
      status: 'planning',
      startedAt: new Date().toISOString(),
      currentStep: 'Generating plan...'
    });
    
    // Log event
    await logEvent({
      type: 'agent',
      severity: 'info',
      title: 'Planning phase started',
      description: `Planning agent started for task: ${task.title}`,
      metadata: { taskId, sessionId, agentType: task.agentType }
    });
    
    // Notify WebSocket clients
    broadcastUpdate('session-started', { taskId, sessionId, sessionType: 'planning' });
    
    // ============================================
    // PHASE 3: Spawn actual planning agent
    // ============================================
    
    // Build planning prompt
    const planningPrompt = `You are a planning agent. Create a detailed execution plan for this task:

**Task:** ${task.title}
**Description:** ${task.description || 'No description provided'}
**Priority:** ${task.priority}
**Agent Type:** ${task.agentType || 'auto'}

Create a plan with:
1. Clear objective
2. 3-7 concrete execution steps
3. Success criteria
4. Estimated time for each step

Save the plan to: ~/.openclaw/workspace/plans/active/${taskId}/plan.md

Use this format:

---
taskId: ${taskId}
status: plan-ready
stepCount: {N}
---

# Execution Plan

## Objective
{Clear objective statement}

## Execution Steps

### Step 1: {Title}
**Agent:** {agentType}
**Time:** {X} minutes

{Detailed instructions}

### Step 2: ...

## Success Criteria
- [ ] {Criterion 1}
- [ ] {Criterion 2}

End with:
PLAN_COMPLETE
Estimated total time: {X} minutes
Confidence: {High|Medium|Low}
`;

    // Spawn planning agent as subagent
    try {
      const planningTask = `Generate execution plan for task "${task.title}" (${taskId}) and save to ~/.openclaw/workspace/plans/active/${taskId}/plan.md. Task description: ${task.description || 'Create a simple HTML to-do list app'}`;
      
      console.log(`ü§ñ Spawning REAL planning agent for task ${taskId}`);
      
      // PRODUCTION: Use real agent to create plan
      const planOutputPath = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId, 'plan.md');
      
      const planningPrompt = `You are a planning agent. Create a detailed execution plan for this task:

**Task Title:** ${task.title}
**Task Description:** ${task.description || 'No description provided'}
**Priority:** ${task.priority}

Create a plan with:
1. Clear objective based on the task
2. 3-7 concrete execution steps that make sense for THIS specific task
3. Realistic time estimates per step
4. Success criteria

Save the plan to: ${planOutputPath}

Use this format:

---
taskId: ${taskId}
status: plan-ready
stepCount: {N}
estimatedMinutes: {total}
---

# Execution Plan: ${task.title}

## Objective
{Clear objective specific to this task}

## Execution Steps

### Step 1: {Step Title}
**Agent:** {coder|ui-designer|researcher|writer|planner}
**Time:** {X} minutes

{Specific instructions for this step}

### Step 2: ...
(continue for each step)

## Success Criteria
- [ ] {Specific criterion}
- [ ] ...

PLAN_COMPLETE
Estimated total time: {X} minutes
Confidence: {High|Medium|Low}`;

      // Execute planning agent
      const planResult = await spawnAgentWithResult({
        task: planningPrompt,
        outputPath: planOutputPath,
        model: 'openrouter/moonshotai/kimi-k2.5',
        timeoutSeconds: 300,
        agentType: 'planner'
      });
      
      if (!planResult.success) {
        throw new Error(`Planning failed: ${planResult.error || 'Unknown error'}`);
      }
      
      console.log(`‚úÖ Planning agent completed for task ${taskId}`);
      console.log(`   Result: ${planResult.result}`);
      
      // Verify plan file exists
      try {
        await fs.access(planOutputPath);
        console.log(`‚úÖ Plan file created: ${planOutputPath}`);
      } catch (err) {
        console.error(`‚ùå Plan file not found: ${planOutputPath}`);
        throw new Error('Planning agent did not create plan file');
      }
      
      // Update session status
      activeSessions.set(sessionId, {
        ...activeSessions.get(sessionId),
        status: 'plan-ready',
        planId: taskId,
        currentStep: 'Plan ready - auto-executing'
      });
      
      // Update task status
      task.executionStatus = 'plan-ready';
      await saveTasks(tasks);
      
      // Log completion
      await appendLog(taskId, {
        level: 'success',
        message: 'Planning complete via agent - auto-executing',
        details: planResult.result,
        timestamp: new Date().toISOString()
      });
      
      // Notify frontend
      broadcastUpdate('plan-ready', { taskId, sessionId });
      
      // ============================================
      // AUTO-EXECUTE: Start execution immediately after planning
      // ============================================
      console.log(`üöÄ Auto-executing plan for task ${taskId}`);
      
      // Small delay to let frontend update, then execute
      setTimeout(async () => {
        try {
          // Remove planning session first
          activeSessions.delete(sessionId);
          broadcastUpdate('session-ended', { sessionId, taskId });
          
          // Trigger execution with real agent
          await executePlan(taskId, task);
          console.log(`‚úÖ Auto-execution started for task ${taskId}`);
        } catch (execErr) {
          console.error(`‚ùå Auto-execution failed for task ${taskId}:`, execErr);
          
          // Update task with error
          const tasks = await getTasks();
          const task = tasks.find(t => t.id === taskId);
          if (task) {
            task.executionStatus = 'error';
            await saveTasks(tasks);
          }
        }
      }, 500);
      
    } catch (spawnErr) {
      console.error('Error in planning phase:', spawnErr);
      
      // Update session to error state
      activeSessions.set(sessionId, {
        ...activeSessions.get(sessionId),
        status: 'error',
        error: spawnErr.message
      });
      
      // Update task to error state
      task.executionStatus = 'error';
      await saveTasks(tasks);
      
      broadcastUpdate('execution-error', { 
        taskId, 
        sessionId,
        error: spawnErr.message 
      });
    }
    
    res.json({
      success: true,
      taskId,
      sessionId,
      status: 'planning',
      message: 'Planning phase initiated'
    });
    
  } catch (err) {
    console.error('Error starting planning phase:', err);
    res.status(500).json({ error: 'Failed to start planning phase' });
  }
});

// POST /plans/:taskId/execute - Trigger plan execution (Phase 4)
// Supports both plan-based execution and direct execution without a plan
app.post('/api/v1/plans/:taskId/execute', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { agentType } = req.body || {};
    
    // Get task details
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === taskId);
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    // Check if plan exists
    const plan = await readPlan(taskId);
    
    // If no plan exists, create a simple one-step plan for direct execution
    if (!plan) {
      console.log(`üìã No plan found for ${taskId}, creating direct execution plan`);
      
      const planDir = path.join(PLANS_CONFIG.ACTIVE_DIR, taskId);
      await fs.mkdir(planDir, { recursive: true });
      
      // Create a simple single-step plan for direct execution
      const directPlanContent = `---
taskId: ${taskId}
created: ${new Date().toISOString()}
status: plan-ready
stepCount: 1
confidence: high
estimatedMinutes: 10
---

# Execution Plan: ${task.title}

## Objective
Complete the task: ${task.title}

## Execution Steps

### Step 1: Execute Task
**Agent:** ${task.agentType || 'auto'}
**Time:** 10 minutes

${task.description || 'Complete the task as specified.'}

Execute the task completely and create any necessary outputs.

## Success Criteria
- [ ] Task completed successfully
- [ ] All outputs created
- [ ] Results verified

PLAN_COMPLETE
Estimated total time: 10 minutes
Confidence: High
`;
      
      await writePlan(taskId, directPlanContent);
      console.log(`‚úÖ Direct execution plan created for ${taskId}`);
    }
    
    // Update task execution status
    task.executionStatus = 'executing';
    task.agentType = agentType || task.agentType || 'auto';
    await saveTasks(tasks);
    
    // Create execution session (Phase 4)
    const execId = `exec-${taskId}-${Date.now()}`;
    const sessionId = `session-${Date.now()}`;
    
    const execSession = {
      id: execId,
      sessionId,
      taskId,
      taskTitle: task.title,
      agentType: task.agentType,
      type: 'execution',
      status: 'executing',
      startedAt: new Date().toISOString(),
      currentStep: 1
    };
    
    executionSessions.set(execId, execSession);
    activeSessions.set(sessionId, {
      id: sessionId,
      taskId,
      taskTitle: task.title,
      agentType: task.agentType,
      type: 'execution',
      status: 'executing',
      startedAt: new Date().toISOString(),
      currentStep: 'Starting execution...'
    });
    
    console.log(`‚úÖ Created execution session: ${sessionId} for task ${taskId}`);
    console.log(`üìä Active sessions count: ${activeSessions.size}`);
    
    // Log event
    await logEvent({
      type: 'agent',
      severity: 'info',
      title: 'Plan execution started',
      description: `Executing plan for task: ${task.title}`,
      metadata: { taskId, execId, sessionId }
    });
    
    // Start execution in background (Phase 4)
    runPlanExecution(taskId, execId).catch(err => {
      console.error(`Background execution failed for ${taskId}:`, err);
    });
    
    // Notify WebSocket clients
    broadcastUpdate('execution-started', { taskId, sessionId, execId });
    
    res.json({
      success: true,
      taskId,
      sessionId,
      execId,
      status: 'executing',
      message: 'Plan execution started'
    });
    
  } catch (err) {
    console.error('Error starting execution:', err);
    res.status(500).json({ error: 'Failed to start execution' });
  }
});

// GET /sessions/active - Get all active sessions
app.get('/api/v1/sessions/active', async (req, res) => {
  try {
    const sessions = Array.from(activeSessions.values());
    console.log(`üì° GET /sessions/active - returning ${sessions.length} sessions`);
    sessions.forEach(s => console.log(`   - ${s.id}: ${s.taskTitle} (${s.type})`));
    res.json({ sessions, count: sessions.length });
  } catch (err) {
    console.error('Error getting active sessions:', err);
    res.status(500).json({ error: 'Failed to get active sessions' });
  }
});

// GET /sessions/history - Get past completed sessions
app.get('/api/v1/sessions/history', async (req, res) => {
  try {
    const { limit = 20 } = req.query;
    const sessions = pastSessions.slice(0, parseInt(limit));
    
    // Calculate totals
    const totalCost = pastSessions.reduce((sum, s) => sum + (s.estimatedCost || 0), 0);
    const totalDuration = pastSessions.reduce((sum, s) => sum + (s.durationMinutes || 0), 0);
    const totalTokens = pastSessions.reduce((sum, s) => sum + (s.tokensUsed || 0), 0);
    
    res.json({ 
      sessions, 
      count: sessions.length,
      totals: {
        cost: Math.round(totalCost * 100) / 100,
        duration: Math.round(totalDuration * 10) / 10,
        tokens: totalTokens
      }
    });
  } catch (err) {
    console.error('Error getting session history:', err);
    res.status(500).json({ error: 'Failed to get session history' });
  }
});

// POST /sessions/:sessionId/kill - Terminate a session
app.post('/api/v1/sessions/:sessionId/kill', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const session = activeSessions.get(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Update task status
    const tasks = await getTasks();
    const task = tasks.find(t => t.id === session.taskId);
    if (task) {
      task.executionStatus = 'error';
      await saveTasks(tasks);
      // await pushToObsidian(task); // DISABLED
    }
    
    // Remove session
    activeSessions.delete(sessionId);
    
    // Log event
    await logEvent({
      type: 'agent',
      severity: 'warning',
      title: 'Session terminated',
      description: `Session ${sessionId} was manually killed`,
      metadata: { sessionId, taskId: session.taskId }
    });
    
    // Notify WebSocket clients
    broadcastUpdate('session-ended', { sessionId, taskId: session.taskId });
    
    res.json({ success: true, sessionId, message: 'Session terminated' });
    
  } catch (err) {
    console.error('Error killing session:', err);
    res.status(500).json({ error: 'Failed to kill session' });
  }
});

// GET /sessions/:sessionId/log - Get session log (placeholder for Phase 4)
app.get('/api/v1/sessions/:sessionId/log', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const session = activeSessions.get(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Return basic session info as log for now
    res.json({
      sessionId,
      logs: [
        { timestamp: session.startedAt, level: 'info', message: 'Session started' },
        { timestamp: new Date().toISOString(), level: 'info', message: session.currentStep }
      ]
    });
    
  } catch (err) {
    console.error('Error getting session log:', err);
    res.status(500).json({ error: 'Failed to get session log' });
  }
});

// ============================================
// INITIALIZATION
// ============================================

async function initialize() {
  // Create necessary directories
  const dirs = [
    CONFIG.OUTPUTS_DIR,
    CONFIG.THUMBNAILS_DIR,
    CONFIG.OBSIDIAN_VAULT,
    path.join(CONFIG.OBSIDIAN_VAULT, 'today'),
    path.join(CONFIG.OBSIDIAN_VAULT, 'tomorrow'),
    path.join(CONFIG.OBSIDIAN_VAULT, 'backlog'),
    path.join(CONFIG.OBSIDIAN_VAULT, 'done')
  ];
  
  for (const dir of dirs) {
    try {
      await fs.mkdir(dir, { recursive: true });
    } catch (err) {
      if (err.code !== 'EEXIST') console.warn(`Could not create ${dir}:`, err.message);
    }
  }
  
  // Initialize storage files if they don't exist
  if (!(await readJson(CONFIG.TASKS_FILE))) {
    await saveTasks([]);
  }
  if (!(await readJson(CONFIG.FILES_FILE))) {
    await saveFiles([]);
  }
  if (!(await readJson(CONFIG.EVENTS_FILE))) {
    await saveEvents([]);
  }
  
  // Initialize plan storage infrastructure (Phase 1)
  await initializePlanStorage();
  
  // DISABLED: File watcher for Obsidian sync - caused flickering/state conflicts
  // await initFileWatcher();
  
  // DISABLED: Periodic Obsidian sync (every 30 seconds) - manual sync only
  // setInterval(async () => {
  //   try {
  //     // await pullFromObsidian(); // DISABLED
  //   } catch (err) {
  //     console.warn('Periodic sync failed:', err.message);
  //   }
  // }, CONFIG.SYNC_INTERVAL_MS);
  
  console.log('üìã Obsidian sync: Manual push only (auto-sync disabled)');
  
  // Log server start
  await logEvent({
    type: 'system',
    severity: 'success',
    title: 'Server started',
    description: `Kanban API server listening on port ${PORT}`,
    metadata: { port: PORT }
  });
  
  console.log(`üöÄ Kanban API Server running at http://localhost:${PORT}/api/v1`);
  console.log(`üì° WebSocket server ready at ws://localhost:${PORT}`);
  console.log(`üìÅ Obsidian vault: ${CONFIG.OBSIDIAN_VAULT}`);
  console.log(`üìã Plan storage: ${PLANS_CONFIG.BASE_DIR}`);
}

// Start the server
server.listen(PORT, '127.0.0.1', () => {
  console.log(`üöÄ Kanban API Server running at http://127.0.0.1:${PORT}/api/v1`);
  console.log(`üì° WebSocket: ws://127.0.0.1:${PORT}`);
});

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

initialize().catch(err => {
  console.error('Failed to initialize server:', err);
  process.exit(1);
});

module.exports = app;
